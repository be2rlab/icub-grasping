/*
 * Copyright (C) 2006-2020 Istituto Italiano di Tecnologia (IIT)
 * All rights reserved.
 *
 * This software may be modified and distributed under the terms of the
 * BSD-3-Clause license. See the accompanying LICENSE file for details.
 */

// Autogenerated by Thrift Compiler (0.12.0-yarped)
//
// This is an automatically generated file.
// It could get re-generated if the ALLOW_IDL_GENERATION flag is on.

#include <depth2kin_IDL.h>

#include <yarp/os/idl/WireTypes.h>

class depth2kin_IDL_getNumExperts_helper :
        public yarp::os::Portable
{
public:
    explicit depth2kin_IDL_getNumExperts_helper();
    bool write(yarp::os::ConnectionWriter& connection) const override;
    bool read(yarp::os::ConnectionReader& connection) override;

    thread_local static std::int32_t s_return_helper;
};

thread_local std::int32_t depth2kin_IDL_getNumExperts_helper::s_return_helper = {};

depth2kin_IDL_getNumExperts_helper::depth2kin_IDL_getNumExperts_helper()
{
    s_return_helper = {};
}

bool depth2kin_IDL_getNumExperts_helper::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    if (!writer.writeListHeader(1)) {
        return false;
    }
    if (!writer.writeTag("getNumExperts", 1, 1)) {
        return false;
    }
    return true;
}

bool depth2kin_IDL_getNumExperts_helper::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    if (!reader.readListReturn()) {
        return false;
    }
    if (!reader.readI32(s_return_helper)) {
        reader.fail();
        return false;
    }
    return true;
}

class depth2kin_IDL_clearExperts_helper :
        public yarp::os::Portable
{
public:
    explicit depth2kin_IDL_clearExperts_helper();
    bool write(yarp::os::ConnectionWriter& connection) const override;
    bool read(yarp::os::ConnectionReader& connection) override;

    thread_local static bool s_return_helper;
};

thread_local bool depth2kin_IDL_clearExperts_helper::s_return_helper = {};

depth2kin_IDL_clearExperts_helper::depth2kin_IDL_clearExperts_helper()
{
    s_return_helper = {};
}

bool depth2kin_IDL_clearExperts_helper::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    if (!writer.writeListHeader(1)) {
        return false;
    }
    if (!writer.writeTag("clearExperts", 1, 1)) {
        return false;
    }
    return true;
}

bool depth2kin_IDL_clearExperts_helper::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    if (!reader.readListReturn()) {
        return false;
    }
    if (!reader.readBool(s_return_helper)) {
        reader.fail();
        return false;
    }
    return true;
}

class depth2kin_IDL_load_helper :
        public yarp::os::Portable
{
public:
    explicit depth2kin_IDL_load_helper();
    bool write(yarp::os::ConnectionWriter& connection) const override;
    bool read(yarp::os::ConnectionReader& connection) override;

    thread_local static bool s_return_helper;
};

thread_local bool depth2kin_IDL_load_helper::s_return_helper = {};

depth2kin_IDL_load_helper::depth2kin_IDL_load_helper()
{
    s_return_helper = {};
}

bool depth2kin_IDL_load_helper::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    if (!writer.writeListHeader(1)) {
        return false;
    }
    if (!writer.writeTag("load", 1, 1)) {
        return false;
    }
    return true;
}

bool depth2kin_IDL_load_helper::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    if (!reader.readListReturn()) {
        return false;
    }
    if (!reader.readBool(s_return_helper)) {
        reader.fail();
        return false;
    }
    return true;
}

class depth2kin_IDL_save_helper :
        public yarp::os::Portable
{
public:
    explicit depth2kin_IDL_save_helper();
    bool write(yarp::os::ConnectionWriter& connection) const override;
    bool read(yarp::os::ConnectionReader& connection) override;

    thread_local static bool s_return_helper;
};

thread_local bool depth2kin_IDL_save_helper::s_return_helper = {};

depth2kin_IDL_save_helper::depth2kin_IDL_save_helper()
{
    s_return_helper = {};
}

bool depth2kin_IDL_save_helper::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    if (!writer.writeListHeader(1)) {
        return false;
    }
    if (!writer.writeTag("save", 1, 1)) {
        return false;
    }
    return true;
}

bool depth2kin_IDL_save_helper::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    if (!reader.readListReturn()) {
        return false;
    }
    if (!reader.readBool(s_return_helper)) {
        reader.fail();
        return false;
    }
    return true;
}

class depth2kin_IDL_log_helper :
        public yarp::os::Portable
{
public:
    explicit depth2kin_IDL_log_helper(const std::string& type);
    bool write(yarp::os::ConnectionWriter& connection) const override;
    bool read(yarp::os::ConnectionReader& connection) override;

    std::string m_type;

    thread_local static bool s_return_helper;
};

thread_local bool depth2kin_IDL_log_helper::s_return_helper = {};

depth2kin_IDL_log_helper::depth2kin_IDL_log_helper(const std::string& type) :
        m_type{type}
{
    s_return_helper = {};
}

bool depth2kin_IDL_log_helper::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    if (!writer.writeListHeader(2)) {
        return false;
    }
    if (!writer.writeTag("log", 1, 1)) {
        return false;
    }
    if (!writer.writeString(m_type)) {
        return false;
    }
    return true;
}

bool depth2kin_IDL_log_helper::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    if (!reader.readListReturn()) {
        return false;
    }
    if (!reader.readBool(s_return_helper)) {
        reader.fail();
        return false;
    }
    return true;
}

class depth2kin_IDL_explore_helper :
        public yarp::os::Portable
{
public:
    explicit depth2kin_IDL_explore_helper();
    bool write(yarp::os::ConnectionWriter& connection) const override;
    bool read(yarp::os::ConnectionReader& connection) override;

    thread_local static bool s_return_helper;
};

thread_local bool depth2kin_IDL_explore_helper::s_return_helper = {};

depth2kin_IDL_explore_helper::depth2kin_IDL_explore_helper()
{
    s_return_helper = {};
}

bool depth2kin_IDL_explore_helper::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    if (!writer.writeListHeader(1)) {
        return false;
    }
    if (!writer.writeTag("explore", 1, 1)) {
        return false;
    }
    return true;
}

bool depth2kin_IDL_explore_helper::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    if (!reader.readListReturn()) {
        return false;
    }
    if (!reader.readBool(s_return_helper)) {
        reader.fail();
        return false;
    }
    return true;
}

class depth2kin_IDL_stop_helper :
        public yarp::os::Portable
{
public:
    explicit depth2kin_IDL_stop_helper();
    bool write(yarp::os::ConnectionWriter& connection) const override;
    bool read(yarp::os::ConnectionReader& connection) override;

    thread_local static bool s_return_helper;
};

thread_local bool depth2kin_IDL_stop_helper::s_return_helper = {};

depth2kin_IDL_stop_helper::depth2kin_IDL_stop_helper()
{
    s_return_helper = {};
}

bool depth2kin_IDL_stop_helper::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    if (!writer.writeListHeader(1)) {
        return false;
    }
    if (!writer.writeTag("stop", 1, 1)) {
        return false;
    }
    return true;
}

bool depth2kin_IDL_stop_helper::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    if (!reader.readListReturn()) {
        return false;
    }
    if (!reader.readBool(s_return_helper)) {
        reader.fail();
        return false;
    }
    return true;
}

class depth2kin_IDL_setMaxDist_helper :
        public yarp::os::Portable
{
public:
    explicit depth2kin_IDL_setMaxDist_helper(const double max_dist);
    bool write(yarp::os::ConnectionWriter& connection) const override;
    bool read(yarp::os::ConnectionReader& connection) override;

    double m_max_dist;

    thread_local static bool s_return_helper;
};

thread_local bool depth2kin_IDL_setMaxDist_helper::s_return_helper = {};

depth2kin_IDL_setMaxDist_helper::depth2kin_IDL_setMaxDist_helper(const double max_dist) :
        m_max_dist{max_dist}
{
    s_return_helper = {};
}

bool depth2kin_IDL_setMaxDist_helper::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    if (!writer.writeListHeader(2)) {
        return false;
    }
    if (!writer.writeTag("setMaxDist", 1, 1)) {
        return false;
    }
    if (!writer.writeFloat64(m_max_dist)) {
        return false;
    }
    return true;
}

bool depth2kin_IDL_setMaxDist_helper::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    if (!reader.readListReturn()) {
        return false;
    }
    if (!reader.readBool(s_return_helper)) {
        reader.fail();
        return false;
    }
    return true;
}

class depth2kin_IDL_getMaxDist_helper :
        public yarp::os::Portable
{
public:
    explicit depth2kin_IDL_getMaxDist_helper();
    bool write(yarp::os::ConnectionWriter& connection) const override;
    bool read(yarp::os::ConnectionReader& connection) override;

    thread_local static double s_return_helper;
};

thread_local double depth2kin_IDL_getMaxDist_helper::s_return_helper = {};

depth2kin_IDL_getMaxDist_helper::depth2kin_IDL_getMaxDist_helper()
{
    s_return_helper = {};
}

bool depth2kin_IDL_getMaxDist_helper::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    if (!writer.writeListHeader(1)) {
        return false;
    }
    if (!writer.writeTag("getMaxDist", 1, 1)) {
        return false;
    }
    return true;
}

bool depth2kin_IDL_getMaxDist_helper::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    if (!reader.readListReturn()) {
        return false;
    }
    if (!reader.readFloat64(s_return_helper)) {
        reader.fail();
        return false;
    }
    return true;
}

class depth2kin_IDL_setRoi_helper :
        public yarp::os::Portable
{
public:
    explicit depth2kin_IDL_setRoi_helper(const std::int32_t side);
    bool write(yarp::os::ConnectionWriter& connection) const override;
    bool read(yarp::os::ConnectionReader& connection) override;

    std::int32_t m_side;

    thread_local static bool s_return_helper;
};

thread_local bool depth2kin_IDL_setRoi_helper::s_return_helper = {};

depth2kin_IDL_setRoi_helper::depth2kin_IDL_setRoi_helper(const std::int32_t side) :
        m_side{side}
{
    s_return_helper = {};
}

bool depth2kin_IDL_setRoi_helper::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    if (!writer.writeListHeader(2)) {
        return false;
    }
    if (!writer.writeTag("setRoi", 1, 1)) {
        return false;
    }
    if (!writer.writeI32(m_side)) {
        return false;
    }
    return true;
}

bool depth2kin_IDL_setRoi_helper::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    if (!reader.readListReturn()) {
        return false;
    }
    if (!reader.readBool(s_return_helper)) {
        reader.fail();
        return false;
    }
    return true;
}

class depth2kin_IDL_getRoi_helper :
        public yarp::os::Portable
{
public:
    explicit depth2kin_IDL_getRoi_helper();
    bool write(yarp::os::ConnectionWriter& connection) const override;
    bool read(yarp::os::ConnectionReader& connection) override;

    thread_local static std::int32_t s_return_helper;
};

thread_local std::int32_t depth2kin_IDL_getRoi_helper::s_return_helper = {};

depth2kin_IDL_getRoi_helper::depth2kin_IDL_getRoi_helper()
{
    s_return_helper = {};
}

bool depth2kin_IDL_getRoi_helper::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    if (!writer.writeListHeader(1)) {
        return false;
    }
    if (!writer.writeTag("getRoi", 1, 1)) {
        return false;
    }
    return true;
}

bool depth2kin_IDL_getRoi_helper::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    if (!reader.readListReturn()) {
        return false;
    }
    if (!reader.readI32(s_return_helper)) {
        reader.fail();
        return false;
    }
    return true;
}

class depth2kin_IDL_setBlockEyes_helper :
        public yarp::os::Portable
{
public:
    explicit depth2kin_IDL_setBlockEyes_helper(const double block_eyes);
    bool write(yarp::os::ConnectionWriter& connection) const override;
    bool read(yarp::os::ConnectionReader& connection) override;

    double m_block_eyes;

    thread_local static bool s_return_helper;
};

thread_local bool depth2kin_IDL_setBlockEyes_helper::s_return_helper = {};

depth2kin_IDL_setBlockEyes_helper::depth2kin_IDL_setBlockEyes_helper(const double block_eyes) :
        m_block_eyes{block_eyes}
{
    s_return_helper = {};
}

bool depth2kin_IDL_setBlockEyes_helper::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    if (!writer.writeListHeader(2)) {
        return false;
    }
    if (!writer.writeTag("setBlockEyes", 1, 1)) {
        return false;
    }
    if (!writer.writeFloat64(m_block_eyes)) {
        return false;
    }
    return true;
}

bool depth2kin_IDL_setBlockEyes_helper::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    if (!reader.readListReturn()) {
        return false;
    }
    if (!reader.readBool(s_return_helper)) {
        reader.fail();
        return false;
    }
    return true;
}

class depth2kin_IDL_getBlockEyes_helper :
        public yarp::os::Portable
{
public:
    explicit depth2kin_IDL_getBlockEyes_helper();
    bool write(yarp::os::ConnectionWriter& connection) const override;
    bool read(yarp::os::ConnectionReader& connection) override;

    thread_local static double s_return_helper;
};

thread_local double depth2kin_IDL_getBlockEyes_helper::s_return_helper = {};

depth2kin_IDL_getBlockEyes_helper::depth2kin_IDL_getBlockEyes_helper()
{
    s_return_helper = {};
}

bool depth2kin_IDL_getBlockEyes_helper::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    if (!writer.writeListHeader(1)) {
        return false;
    }
    if (!writer.writeTag("getBlockEyes", 1, 1)) {
        return false;
    }
    return true;
}

bool depth2kin_IDL_getBlockEyes_helper::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    if (!reader.readListReturn()) {
        return false;
    }
    if (!reader.readFloat64(s_return_helper)) {
        reader.fail();
        return false;
    }
    return true;
}

class depth2kin_IDL_blockEyes_helper :
        public yarp::os::Portable
{
public:
    explicit depth2kin_IDL_blockEyes_helper();
    bool write(yarp::os::ConnectionWriter& connection) const override;
    bool read(yarp::os::ConnectionReader& connection) override;

    thread_local static bool s_return_helper;
};

thread_local bool depth2kin_IDL_blockEyes_helper::s_return_helper = {};

depth2kin_IDL_blockEyes_helper::depth2kin_IDL_blockEyes_helper()
{
    s_return_helper = {};
}

bool depth2kin_IDL_blockEyes_helper::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    if (!writer.writeListHeader(1)) {
        return false;
    }
    if (!writer.writeTag("blockEyes", 1, 1)) {
        return false;
    }
    return true;
}

bool depth2kin_IDL_blockEyes_helper::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    if (!reader.readListReturn()) {
        return false;
    }
    if (!reader.readBool(s_return_helper)) {
        reader.fail();
        return false;
    }
    return true;
}

class depth2kin_IDL_clearEyes_helper :
        public yarp::os::Portable
{
public:
    explicit depth2kin_IDL_clearEyes_helper();
    bool write(yarp::os::ConnectionWriter& connection) const override;
    bool read(yarp::os::ConnectionReader& connection) override;

    thread_local static bool s_return_helper;
};

thread_local bool depth2kin_IDL_clearEyes_helper::s_return_helper = {};

depth2kin_IDL_clearEyes_helper::depth2kin_IDL_clearEyes_helper()
{
    s_return_helper = {};
}

bool depth2kin_IDL_clearEyes_helper::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    if (!writer.writeListHeader(1)) {
        return false;
    }
    if (!writer.writeTag("clearEyes", 1, 1)) {
        return false;
    }
    return true;
}

bool depth2kin_IDL_clearEyes_helper::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    if (!reader.readListReturn()) {
        return false;
    }
    if (!reader.readBool(s_return_helper)) {
        reader.fail();
        return false;
    }
    return true;
}

class depth2kin_IDL_setArm_helper :
        public yarp::os::Portable
{
public:
    explicit depth2kin_IDL_setArm_helper(const std::string& arm);
    bool write(yarp::os::ConnectionWriter& connection) const override;
    bool read(yarp::os::ConnectionReader& connection) override;

    std::string m_arm;

    thread_local static bool s_return_helper;
};

thread_local bool depth2kin_IDL_setArm_helper::s_return_helper = {};

depth2kin_IDL_setArm_helper::depth2kin_IDL_setArm_helper(const std::string& arm) :
        m_arm{arm}
{
    s_return_helper = {};
}

bool depth2kin_IDL_setArm_helper::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    if (!writer.writeListHeader(2)) {
        return false;
    }
    if (!writer.writeTag("setArm", 1, 1)) {
        return false;
    }
    if (!writer.writeString(m_arm)) {
        return false;
    }
    return true;
}

bool depth2kin_IDL_setArm_helper::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    if (!reader.readListReturn()) {
        return false;
    }
    if (!reader.readBool(s_return_helper)) {
        reader.fail();
        return false;
    }
    return true;
}

class depth2kin_IDL_getArm_helper :
        public yarp::os::Portable
{
public:
    explicit depth2kin_IDL_getArm_helper();
    bool write(yarp::os::ConnectionWriter& connection) const override;
    bool read(yarp::os::ConnectionReader& connection) override;

    thread_local static std::string s_return_helper;
};

thread_local std::string depth2kin_IDL_getArm_helper::s_return_helper = {};

depth2kin_IDL_getArm_helper::depth2kin_IDL_getArm_helper()
{
    s_return_helper = {};
}

bool depth2kin_IDL_getArm_helper::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    if (!writer.writeListHeader(1)) {
        return false;
    }
    if (!writer.writeTag("getArm", 1, 1)) {
        return false;
    }
    return true;
}

bool depth2kin_IDL_getArm_helper::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    if (!reader.readListReturn()) {
        return false;
    }
    if (!reader.readString(s_return_helper)) {
        reader.fail();
        return false;
    }
    return true;
}

class depth2kin_IDL_setCalibrationType_helper :
        public yarp::os::Portable
{
public:
    explicit depth2kin_IDL_setCalibrationType_helper(const std::string& type, const std::string& extrapolation);
    bool write(yarp::os::ConnectionWriter& connection) const override;
    bool read(yarp::os::ConnectionReader& connection) override;

    std::string m_type;
    std::string m_extrapolation;

    thread_local static bool s_return_helper;
};

thread_local bool depth2kin_IDL_setCalibrationType_helper::s_return_helper = {};

depth2kin_IDL_setCalibrationType_helper::depth2kin_IDL_setCalibrationType_helper(const std::string& type, const std::string& extrapolation) :
        m_type{type},
        m_extrapolation{extrapolation}
{
    s_return_helper = {};
}

bool depth2kin_IDL_setCalibrationType_helper::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    if (!writer.writeListHeader(3)) {
        return false;
    }
    if (!writer.writeTag("setCalibrationType", 1, 1)) {
        return false;
    }
    if (!writer.writeString(m_type)) {
        return false;
    }
    if (!writer.writeString(m_extrapolation)) {
        return false;
    }
    return true;
}

bool depth2kin_IDL_setCalibrationType_helper::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    if (!reader.readListReturn()) {
        return false;
    }
    if (!reader.readBool(s_return_helper)) {
        reader.fail();
        return false;
    }
    return true;
}

class depth2kin_IDL_getCalibrationType_helper :
        public yarp::os::Portable
{
public:
    explicit depth2kin_IDL_getCalibrationType_helper();
    bool write(yarp::os::ConnectionWriter& connection) const override;
    bool read(yarp::os::ConnectionReader& connection) override;

    thread_local static std::string s_return_helper;
};

thread_local std::string depth2kin_IDL_getCalibrationType_helper::s_return_helper = {};

depth2kin_IDL_getCalibrationType_helper::depth2kin_IDL_getCalibrationType_helper()
{
    s_return_helper = {};
}

bool depth2kin_IDL_getCalibrationType_helper::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    if (!writer.writeListHeader(1)) {
        return false;
    }
    if (!writer.writeTag("getCalibrationType", 1, 1)) {
        return false;
    }
    return true;
}

bool depth2kin_IDL_getCalibrationType_helper::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    if (!reader.readListReturn()) {
        return false;
    }
    if (!reader.readString(s_return_helper)) {
        reader.fail();
        return false;
    }
    return true;
}

class depth2kin_IDL_calibrate_helper :
        public yarp::os::Portable
{
public:
    explicit depth2kin_IDL_calibrate_helper(const bool rm_outliers);
    bool write(yarp::os::ConnectionWriter& connection) const override;
    bool read(yarp::os::ConnectionReader& connection) override;

    bool m_rm_outliers;

    thread_local static yarp::os::Property s_return_helper;
};

thread_local yarp::os::Property depth2kin_IDL_calibrate_helper::s_return_helper = {};

depth2kin_IDL_calibrate_helper::depth2kin_IDL_calibrate_helper(const bool rm_outliers) :
        m_rm_outliers{rm_outliers}
{
}

bool depth2kin_IDL_calibrate_helper::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    if (!writer.writeListHeader(2)) {
        return false;
    }
    if (!writer.writeTag("calibrate", 1, 1)) {
        return false;
    }
    if (!writer.writeBool(m_rm_outliers)) {
        return false;
    }
    return true;
}

bool depth2kin_IDL_calibrate_helper::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    if (!reader.readListReturn()) {
        return false;
    }
    if (!reader.read(s_return_helper)) {
        reader.fail();
        return false;
    }
    return true;
}

class depth2kin_IDL_pushCalibrator_helper :
        public yarp::os::Portable
{
public:
    explicit depth2kin_IDL_pushCalibrator_helper();
    bool write(yarp::os::ConnectionWriter& connection) const override;
    bool read(yarp::os::ConnectionReader& connection) override;

    thread_local static bool s_return_helper;
};

thread_local bool depth2kin_IDL_pushCalibrator_helper::s_return_helper = {};

depth2kin_IDL_pushCalibrator_helper::depth2kin_IDL_pushCalibrator_helper()
{
    s_return_helper = {};
}

bool depth2kin_IDL_pushCalibrator_helper::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    if (!writer.writeListHeader(1)) {
        return false;
    }
    if (!writer.writeTag("pushCalibrator", 1, 1)) {
        return false;
    }
    return true;
}

bool depth2kin_IDL_pushCalibrator_helper::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    if (!reader.readListReturn()) {
        return false;
    }
    if (!reader.readBool(s_return_helper)) {
        reader.fail();
        return false;
    }
    return true;
}

class depth2kin_IDL_setTouchWithExperts_helper :
        public yarp::os::Portable
{
public:
    explicit depth2kin_IDL_setTouchWithExperts_helper(const std::string& sw);
    bool write(yarp::os::ConnectionWriter& connection) const override;
    bool read(yarp::os::ConnectionReader& connection) override;

    std::string m_sw;

    thread_local static bool s_return_helper;
};

thread_local bool depth2kin_IDL_setTouchWithExperts_helper::s_return_helper = {};

depth2kin_IDL_setTouchWithExperts_helper::depth2kin_IDL_setTouchWithExperts_helper(const std::string& sw) :
        m_sw{sw}
{
    s_return_helper = {};
}

bool depth2kin_IDL_setTouchWithExperts_helper::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    if (!writer.writeListHeader(2)) {
        return false;
    }
    if (!writer.writeTag("setTouchWithExperts", 1, 1)) {
        return false;
    }
    if (!writer.writeString(m_sw)) {
        return false;
    }
    return true;
}

bool depth2kin_IDL_setTouchWithExperts_helper::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    if (!reader.readListReturn()) {
        return false;
    }
    if (!reader.readBool(s_return_helper)) {
        reader.fail();
        return false;
    }
    return true;
}

class depth2kin_IDL_getTouchWithExperts_helper :
        public yarp::os::Portable
{
public:
    explicit depth2kin_IDL_getTouchWithExperts_helper();
    bool write(yarp::os::ConnectionWriter& connection) const override;
    bool read(yarp::os::ConnectionReader& connection) override;

    thread_local static std::string s_return_helper;
};

thread_local std::string depth2kin_IDL_getTouchWithExperts_helper::s_return_helper = {};

depth2kin_IDL_getTouchWithExperts_helper::depth2kin_IDL_getTouchWithExperts_helper()
{
    s_return_helper = {};
}

bool depth2kin_IDL_getTouchWithExperts_helper::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    if (!writer.writeListHeader(1)) {
        return false;
    }
    if (!writer.writeTag("getTouchWithExperts", 1, 1)) {
        return false;
    }
    return true;
}

bool depth2kin_IDL_getTouchWithExperts_helper::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    if (!reader.readListReturn()) {
        return false;
    }
    if (!reader.readString(s_return_helper)) {
        reader.fail();
        return false;
    }
    return true;
}

class depth2kin_IDL_touch_helper :
        public yarp::os::Portable
{
public:
    explicit depth2kin_IDL_touch_helper(const std::int32_t u, const std::int32_t v);
    bool write(yarp::os::ConnectionWriter& connection) const override;
    bool read(yarp::os::ConnectionReader& connection) override;

    std::int32_t m_u;
    std::int32_t m_v;

    thread_local static bool s_return_helper;
};

thread_local bool depth2kin_IDL_touch_helper::s_return_helper = {};

depth2kin_IDL_touch_helper::depth2kin_IDL_touch_helper(const std::int32_t u, const std::int32_t v) :
        m_u{u},
        m_v{v}
{
    s_return_helper = {};
}

bool depth2kin_IDL_touch_helper::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    if (!writer.writeListHeader(3)) {
        return false;
    }
    if (!writer.writeTag("touch", 1, 1)) {
        return false;
    }
    if (!writer.writeI32(m_u)) {
        return false;
    }
    if (!writer.writeI32(m_v)) {
        return false;
    }
    return true;
}

bool depth2kin_IDL_touch_helper::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    if (!reader.readListReturn()) {
        return false;
    }
    if (!reader.readBool(s_return_helper)) {
        reader.fail();
        return false;
    }
    return true;
}

class depth2kin_IDL_getPoint_helper :
        public yarp::os::Portable
{
public:
    explicit depth2kin_IDL_getPoint_helper(const std::string& arm, const double x, const double y, const double z);
    bool write(yarp::os::ConnectionWriter& connection) const override;
    bool read(yarp::os::ConnectionReader& connection) override;

    std::string m_arm;
    double m_x;
    double m_y;
    double m_z;

    thread_local static PointReq s_return_helper;
};

thread_local PointReq depth2kin_IDL_getPoint_helper::s_return_helper = {};

depth2kin_IDL_getPoint_helper::depth2kin_IDL_getPoint_helper(const std::string& arm, const double x, const double y, const double z) :
        m_arm{arm},
        m_x{x},
        m_y{y},
        m_z{z}
{
}

bool depth2kin_IDL_getPoint_helper::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    if (!writer.writeListHeader(5)) {
        return false;
    }
    if (!writer.writeTag("getPoint", 1, 1)) {
        return false;
    }
    if (!writer.writeString(m_arm)) {
        return false;
    }
    if (!writer.writeFloat64(m_x)) {
        return false;
    }
    if (!writer.writeFloat64(m_y)) {
        return false;
    }
    if (!writer.writeFloat64(m_z)) {
        return false;
    }
    return true;
}

bool depth2kin_IDL_getPoint_helper::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    if (!reader.readListReturn()) {
        return false;
    }
    if (!reader.read(s_return_helper)) {
        reader.fail();
        return false;
    }
    return true;
}

class depth2kin_IDL_getPoints_helper :
        public yarp::os::Portable
{
public:
    explicit depth2kin_IDL_getPoints_helper(const std::string& arm, const std::vector<double>& coordinates);
    bool write(yarp::os::ConnectionWriter& connection) const override;
    bool read(yarp::os::ConnectionReader& connection) override;

    std::string m_arm;
    std::vector<double> m_coordinates;

    thread_local static std::vector<PointReq> s_return_helper;
};

thread_local std::vector<PointReq> depth2kin_IDL_getPoints_helper::s_return_helper = {};

depth2kin_IDL_getPoints_helper::depth2kin_IDL_getPoints_helper(const std::string& arm, const std::vector<double>& coordinates) :
        m_arm{arm},
        m_coordinates{coordinates}
{
}

bool depth2kin_IDL_getPoints_helper::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    if (!writer.writeListHeader(3)) {
        return false;
    }
    if (!writer.writeTag("getPoints", 1, 1)) {
        return false;
    }
    if (!writer.writeString(m_arm)) {
        return false;
    }
    if (!writer.writeListBegin(BOTTLE_TAG_FLOAT64, static_cast<uint32_t>(m_coordinates.size()))) {
        return false;
    }
    for (const auto& _item0 : m_coordinates) {
        if (!writer.writeFloat64(_item0)) {
            return false;
        }
    }
    if (!writer.writeListEnd()) {
        return false;
    }
    return true;
}

bool depth2kin_IDL_getPoints_helper::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    if (!reader.readListReturn()) {
        return false;
    }
    s_return_helper.clear();
    uint32_t _size1;
    yarp::os::idl::WireState _etype4;
    reader.readListBegin(_etype4, _size1);
    s_return_helper.resize(_size1);
    for (size_t _i5 = 0; _i5 < _size1; ++_i5) {
        if (!reader.readNested(s_return_helper[_i5])) {
            reader.fail();
            return false;
        }
    }
    reader.readListEnd();
    return true;
}

class depth2kin_IDL_setExperiment_helper :
        public yarp::os::Portable
{
public:
    explicit depth2kin_IDL_setExperiment_helper(const std::string& exp, const std::string& v);
    bool write(yarp::os::ConnectionWriter& connection) const override;
    bool read(yarp::os::ConnectionReader& connection) override;

    std::string m_exp;
    std::string m_v;

    thread_local static bool s_return_helper;
};

thread_local bool depth2kin_IDL_setExperiment_helper::s_return_helper = {};

depth2kin_IDL_setExperiment_helper::depth2kin_IDL_setExperiment_helper(const std::string& exp, const std::string& v) :
        m_exp{exp},
        m_v{v}
{
    s_return_helper = {};
}

bool depth2kin_IDL_setExperiment_helper::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    if (!writer.writeListHeader(3)) {
        return false;
    }
    if (!writer.writeTag("setExperiment", 1, 1)) {
        return false;
    }
    if (!writer.writeString(m_exp)) {
        return false;
    }
    if (!writer.writeString(m_v)) {
        return false;
    }
    return true;
}

bool depth2kin_IDL_setExperiment_helper::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    if (!reader.readListReturn()) {
        return false;
    }
    if (!reader.readBool(s_return_helper)) {
        reader.fail();
        return false;
    }
    return true;
}

class depth2kin_IDL_getExperiment_helper :
        public yarp::os::Portable
{
public:
    explicit depth2kin_IDL_getExperiment_helper(const std::string& exp);
    bool write(yarp::os::ConnectionWriter& connection) const override;
    bool read(yarp::os::ConnectionReader& connection) override;

    std::string m_exp;

    thread_local static std::string s_return_helper;
};

thread_local std::string depth2kin_IDL_getExperiment_helper::s_return_helper = {};

depth2kin_IDL_getExperiment_helper::depth2kin_IDL_getExperiment_helper(const std::string& exp) :
        m_exp{exp}
{
    s_return_helper = {};
}

bool depth2kin_IDL_getExperiment_helper::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    if (!writer.writeListHeader(2)) {
        return false;
    }
    if (!writer.writeTag("getExperiment", 1, 1)) {
        return false;
    }
    if (!writer.writeString(m_exp)) {
        return false;
    }
    return true;
}

bool depth2kin_IDL_getExperiment_helper::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    if (!reader.readListReturn()) {
        return false;
    }
    if (!reader.readString(s_return_helper)) {
        reader.fail();
        return false;
    }
    return true;
}

class depth2kin_IDL_getExtrinsics_helper :
        public yarp::os::Portable
{
public:
    explicit depth2kin_IDL_getExtrinsics_helper(const std::string& eye);
    bool write(yarp::os::ConnectionWriter& connection) const override;
    bool read(yarp::os::ConnectionReader& connection) override;

    std::string m_eye;

    thread_local static yarp::sig::Vector s_return_helper;
};

thread_local yarp::sig::Vector depth2kin_IDL_getExtrinsics_helper::s_return_helper = {};

depth2kin_IDL_getExtrinsics_helper::depth2kin_IDL_getExtrinsics_helper(const std::string& eye) :
        m_eye{eye}
{
}

bool depth2kin_IDL_getExtrinsics_helper::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    if (!writer.writeListHeader(2)) {
        return false;
    }
    if (!writer.writeTag("getExtrinsics", 1, 1)) {
        return false;
    }
    if (!writer.writeString(m_eye)) {
        return false;
    }
    return true;
}

bool depth2kin_IDL_getExtrinsics_helper::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    if (!reader.readListReturn()) {
        return false;
    }
    if (!reader.read(s_return_helper)) {
        reader.fail();
        return false;
    }
    return true;
}

class depth2kin_IDL_resetExtrinsics_helper :
        public yarp::os::Portable
{
public:
    explicit depth2kin_IDL_resetExtrinsics_helper(const std::string& eye);
    bool write(yarp::os::ConnectionWriter& connection) const override;
    bool read(yarp::os::ConnectionReader& connection) override;

    std::string m_eye;

    thread_local static bool s_return_helper;
};

thread_local bool depth2kin_IDL_resetExtrinsics_helper::s_return_helper = {};

depth2kin_IDL_resetExtrinsics_helper::depth2kin_IDL_resetExtrinsics_helper(const std::string& eye) :
        m_eye{eye}
{
    s_return_helper = {};
}

bool depth2kin_IDL_resetExtrinsics_helper::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    if (!writer.writeListHeader(2)) {
        return false;
    }
    if (!writer.writeTag("resetExtrinsics", 1, 1)) {
        return false;
    }
    if (!writer.writeString(m_eye)) {
        return false;
    }
    return true;
}

bool depth2kin_IDL_resetExtrinsics_helper::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    if (!reader.readListReturn()) {
        return false;
    }
    if (!reader.readBool(s_return_helper)) {
        reader.fail();
        return false;
    }
    return true;
}

class depth2kin_IDL_setExplorationWait_helper :
        public yarp::os::Portable
{
public:
    explicit depth2kin_IDL_setExplorationWait_helper(const double wait);
    bool write(yarp::os::ConnectionWriter& connection) const override;
    bool read(yarp::os::ConnectionReader& connection) override;

    double m_wait;

    thread_local static bool s_return_helper;
};

thread_local bool depth2kin_IDL_setExplorationWait_helper::s_return_helper = {};

depth2kin_IDL_setExplorationWait_helper::depth2kin_IDL_setExplorationWait_helper(const double wait) :
        m_wait{wait}
{
    s_return_helper = {};
}

bool depth2kin_IDL_setExplorationWait_helper::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    if (!writer.writeListHeader(2)) {
        return false;
    }
    if (!writer.writeTag("setExplorationWait", 1, 1)) {
        return false;
    }
    if (!writer.writeFloat64(m_wait)) {
        return false;
    }
    return true;
}

bool depth2kin_IDL_setExplorationWait_helper::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    if (!reader.readListReturn()) {
        return false;
    }
    if (!reader.readBool(s_return_helper)) {
        reader.fail();
        return false;
    }
    return true;
}

class depth2kin_IDL_getExplorationWait_helper :
        public yarp::os::Portable
{
public:
    explicit depth2kin_IDL_getExplorationWait_helper();
    bool write(yarp::os::ConnectionWriter& connection) const override;
    bool read(yarp::os::ConnectionReader& connection) override;

    thread_local static double s_return_helper;
};

thread_local double depth2kin_IDL_getExplorationWait_helper::s_return_helper = {};

depth2kin_IDL_getExplorationWait_helper::depth2kin_IDL_getExplorationWait_helper()
{
    s_return_helper = {};
}

bool depth2kin_IDL_getExplorationWait_helper::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    if (!writer.writeListHeader(1)) {
        return false;
    }
    if (!writer.writeTag("getExplorationWait", 1, 1)) {
        return false;
    }
    return true;
}

bool depth2kin_IDL_getExplorationWait_helper::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    if (!reader.readListReturn()) {
        return false;
    }
    if (!reader.readFloat64(s_return_helper)) {
        reader.fail();
        return false;
    }
    return true;
}

class depth2kin_IDL_setExplorationInTargetTol_helper :
        public yarp::os::Portable
{
public:
    explicit depth2kin_IDL_setExplorationInTargetTol_helper(const double tol);
    bool write(yarp::os::ConnectionWriter& connection) const override;
    bool read(yarp::os::ConnectionReader& connection) override;

    double m_tol;

    thread_local static bool s_return_helper;
};

thread_local bool depth2kin_IDL_setExplorationInTargetTol_helper::s_return_helper = {};

depth2kin_IDL_setExplorationInTargetTol_helper::depth2kin_IDL_setExplorationInTargetTol_helper(const double tol) :
        m_tol{tol}
{
    s_return_helper = {};
}

bool depth2kin_IDL_setExplorationInTargetTol_helper::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    if (!writer.writeListHeader(2)) {
        return false;
    }
    if (!writer.writeTag("setExplorationInTargetTol", 1, 1)) {
        return false;
    }
    if (!writer.writeFloat64(m_tol)) {
        return false;
    }
    return true;
}

bool depth2kin_IDL_setExplorationInTargetTol_helper::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    if (!reader.readListReturn()) {
        return false;
    }
    if (!reader.readBool(s_return_helper)) {
        reader.fail();
        return false;
    }
    return true;
}

class depth2kin_IDL_getExplorationInTargetTol_helper :
        public yarp::os::Portable
{
public:
    explicit depth2kin_IDL_getExplorationInTargetTol_helper();
    bool write(yarp::os::ConnectionWriter& connection) const override;
    bool read(yarp::os::ConnectionReader& connection) override;

    thread_local static double s_return_helper;
};

thread_local double depth2kin_IDL_getExplorationInTargetTol_helper::s_return_helper = {};

depth2kin_IDL_getExplorationInTargetTol_helper::depth2kin_IDL_getExplorationInTargetTol_helper()
{
    s_return_helper = {};
}

bool depth2kin_IDL_getExplorationInTargetTol_helper::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    if (!writer.writeListHeader(1)) {
        return false;
    }
    if (!writer.writeTag("getExplorationInTargetTol", 1, 1)) {
        return false;
    }
    return true;
}

bool depth2kin_IDL_getExplorationInTargetTol_helper::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    if (!reader.readListReturn()) {
        return false;
    }
    if (!reader.readFloat64(s_return_helper)) {
        reader.fail();
        return false;
    }
    return true;
}

class depth2kin_IDL_setTouchInTargetTol_helper :
        public yarp::os::Portable
{
public:
    explicit depth2kin_IDL_setTouchInTargetTol_helper(const double tol);
    bool write(yarp::os::ConnectionWriter& connection) const override;
    bool read(yarp::os::ConnectionReader& connection) override;

    double m_tol;

    thread_local static bool s_return_helper;
};

thread_local bool depth2kin_IDL_setTouchInTargetTol_helper::s_return_helper = {};

depth2kin_IDL_setTouchInTargetTol_helper::depth2kin_IDL_setTouchInTargetTol_helper(const double tol) :
        m_tol{tol}
{
    s_return_helper = {};
}

bool depth2kin_IDL_setTouchInTargetTol_helper::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    if (!writer.writeListHeader(2)) {
        return false;
    }
    if (!writer.writeTag("setTouchInTargetTol", 1, 1)) {
        return false;
    }
    if (!writer.writeFloat64(m_tol)) {
        return false;
    }
    return true;
}

bool depth2kin_IDL_setTouchInTargetTol_helper::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    if (!reader.readListReturn()) {
        return false;
    }
    if (!reader.readBool(s_return_helper)) {
        reader.fail();
        return false;
    }
    return true;
}

class depth2kin_IDL_getTouchInTargetTol_helper :
        public yarp::os::Portable
{
public:
    explicit depth2kin_IDL_getTouchInTargetTol_helper();
    bool write(yarp::os::ConnectionWriter& connection) const override;
    bool read(yarp::os::ConnectionReader& connection) override;

    thread_local static double s_return_helper;
};

thread_local double depth2kin_IDL_getTouchInTargetTol_helper::s_return_helper = {};

depth2kin_IDL_getTouchInTargetTol_helper::depth2kin_IDL_getTouchInTargetTol_helper()
{
    s_return_helper = {};
}

bool depth2kin_IDL_getTouchInTargetTol_helper::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    if (!writer.writeListHeader(1)) {
        return false;
    }
    if (!writer.writeTag("getTouchInTargetTol", 1, 1)) {
        return false;
    }
    return true;
}

bool depth2kin_IDL_getTouchInTargetTol_helper::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    if (!reader.readListReturn()) {
        return false;
    }
    if (!reader.readFloat64(s_return_helper)) {
        reader.fail();
        return false;
    }
    return true;
}

class depth2kin_IDL_setExplorationSpace_helper :
        public yarp::os::Portable
{
public:
    explicit depth2kin_IDL_setExplorationSpace_helper(const double cx, const double cy, const double cz, const double a, const double b);
    bool write(yarp::os::ConnectionWriter& connection) const override;
    bool read(yarp::os::ConnectionReader& connection) override;

    double m_cx;
    double m_cy;
    double m_cz;
    double m_a;
    double m_b;

    thread_local static bool s_return_helper;
};

thread_local bool depth2kin_IDL_setExplorationSpace_helper::s_return_helper = {};

depth2kin_IDL_setExplorationSpace_helper::depth2kin_IDL_setExplorationSpace_helper(const double cx, const double cy, const double cz, const double a, const double b) :
        m_cx{cx},
        m_cy{cy},
        m_cz{cz},
        m_a{a},
        m_b{b}
{
    s_return_helper = {};
}

bool depth2kin_IDL_setExplorationSpace_helper::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    if (!writer.writeListHeader(6)) {
        return false;
    }
    if (!writer.writeTag("setExplorationSpace", 1, 1)) {
        return false;
    }
    if (!writer.writeFloat64(m_cx)) {
        return false;
    }
    if (!writer.writeFloat64(m_cy)) {
        return false;
    }
    if (!writer.writeFloat64(m_cz)) {
        return false;
    }
    if (!writer.writeFloat64(m_a)) {
        return false;
    }
    if (!writer.writeFloat64(m_b)) {
        return false;
    }
    return true;
}

bool depth2kin_IDL_setExplorationSpace_helper::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    if (!reader.readListReturn()) {
        return false;
    }
    if (!reader.readBool(s_return_helper)) {
        reader.fail();
        return false;
    }
    return true;
}

class depth2kin_IDL_setExplorationSpaceDelta_helper :
        public yarp::os::Portable
{
public:
    explicit depth2kin_IDL_setExplorationSpaceDelta_helper(const double dcx, const double dcy, const double dcz, const double da, const double db);
    bool write(yarp::os::ConnectionWriter& connection) const override;
    bool read(yarp::os::ConnectionReader& connection) override;

    double m_dcx;
    double m_dcy;
    double m_dcz;
    double m_da;
    double m_db;

    thread_local static bool s_return_helper;
};

thread_local bool depth2kin_IDL_setExplorationSpaceDelta_helper::s_return_helper = {};

depth2kin_IDL_setExplorationSpaceDelta_helper::depth2kin_IDL_setExplorationSpaceDelta_helper(const double dcx, const double dcy, const double dcz, const double da, const double db) :
        m_dcx{dcx},
        m_dcy{dcy},
        m_dcz{dcz},
        m_da{da},
        m_db{db}
{
    s_return_helper = {};
}

bool depth2kin_IDL_setExplorationSpaceDelta_helper::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    if (!writer.writeListHeader(6)) {
        return false;
    }
    if (!writer.writeTag("setExplorationSpaceDelta", 1, 1)) {
        return false;
    }
    if (!writer.writeFloat64(m_dcx)) {
        return false;
    }
    if (!writer.writeFloat64(m_dcy)) {
        return false;
    }
    if (!writer.writeFloat64(m_dcz)) {
        return false;
    }
    if (!writer.writeFloat64(m_da)) {
        return false;
    }
    if (!writer.writeFloat64(m_db)) {
        return false;
    }
    return true;
}

bool depth2kin_IDL_setExplorationSpaceDelta_helper::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    if (!reader.readListReturn()) {
        return false;
    }
    if (!reader.readBool(s_return_helper)) {
        reader.fail();
        return false;
    }
    return true;
}

class depth2kin_IDL_getExplorationData_helper :
        public yarp::os::Portable
{
public:
    explicit depth2kin_IDL_getExplorationData_helper();
    bool write(yarp::os::ConnectionWriter& connection) const override;
    bool read(yarp::os::ConnectionReader& connection) override;

    thread_local static yarp::os::Property s_return_helper;
};

thread_local yarp::os::Property depth2kin_IDL_getExplorationData_helper::s_return_helper = {};

depth2kin_IDL_getExplorationData_helper::depth2kin_IDL_getExplorationData_helper()
{
}

bool depth2kin_IDL_getExplorationData_helper::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    if (!writer.writeListHeader(1)) {
        return false;
    }
    if (!writer.writeTag("getExplorationData", 1, 1)) {
        return false;
    }
    return true;
}

bool depth2kin_IDL_getExplorationData_helper::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    if (!reader.readListReturn()) {
        return false;
    }
    if (!reader.read(s_return_helper)) {
        reader.fail();
        return false;
    }
    return true;
}

class depth2kin_IDL_clearExplorationData_helper :
        public yarp::os::Portable
{
public:
    explicit depth2kin_IDL_clearExplorationData_helper();
    bool write(yarp::os::ConnectionWriter& connection) const override;
    bool read(yarp::os::ConnectionReader& connection) override;

    thread_local static bool s_return_helper;
};

thread_local bool depth2kin_IDL_clearExplorationData_helper::s_return_helper = {};

depth2kin_IDL_clearExplorationData_helper::depth2kin_IDL_clearExplorationData_helper()
{
    s_return_helper = {};
}

bool depth2kin_IDL_clearExplorationData_helper::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    if (!writer.writeListHeader(1)) {
        return false;
    }
    if (!writer.writeTag("clearExplorationData", 1, 1)) {
        return false;
    }
    return true;
}

bool depth2kin_IDL_clearExplorationData_helper::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    if (!reader.readListReturn()) {
        return false;
    }
    if (!reader.readBool(s_return_helper)) {
        reader.fail();
        return false;
    }
    return true;
}

class depth2kin_IDL_posture_helper :
        public yarp::os::Portable
{
public:
    explicit depth2kin_IDL_posture_helper(const std::string& type);
    bool write(yarp::os::ConnectionWriter& connection) const override;
    bool read(yarp::os::ConnectionReader& connection) override;

    std::string m_type;

    thread_local static bool s_return_helper;
};

thread_local bool depth2kin_IDL_posture_helper::s_return_helper = {};

depth2kin_IDL_posture_helper::depth2kin_IDL_posture_helper(const std::string& type) :
        m_type{type}
{
    s_return_helper = {};
}

bool depth2kin_IDL_posture_helper::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    if (!writer.writeListHeader(2)) {
        return false;
    }
    if (!writer.writeTag("posture", 1, 1)) {
        return false;
    }
    if (!writer.writeString(m_type)) {
        return false;
    }
    return true;
}

bool depth2kin_IDL_posture_helper::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    if (!reader.readListReturn()) {
        return false;
    }
    if (!reader.readBool(s_return_helper)) {
        reader.fail();
        return false;
    }
    return true;
}

class depth2kin_IDL_calibrateDepth_helper :
        public yarp::os::Portable
{
public:
    explicit depth2kin_IDL_calibrateDepth_helper();
    bool write(yarp::os::ConnectionWriter& connection) const override;
    bool read(yarp::os::ConnectionReader& connection) override;

    thread_local static bool s_return_helper;
};

thread_local bool depth2kin_IDL_calibrateDepth_helper::s_return_helper = {};

depth2kin_IDL_calibrateDepth_helper::depth2kin_IDL_calibrateDepth_helper()
{
    s_return_helper = {};
}

bool depth2kin_IDL_calibrateDepth_helper::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    if (!writer.writeListHeader(1)) {
        return false;
    }
    if (!writer.writeTag("calibrateDepth", 1, 1)) {
        return false;
    }
    return true;
}

bool depth2kin_IDL_calibrateDepth_helper::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    if (!reader.readListReturn()) {
        return false;
    }
    if (!reader.readBool(s_return_helper)) {
        reader.fail();
        return false;
    }
    return true;
}

class depth2kin_IDL_quit_helper :
        public yarp::os::Portable
{
public:
    explicit depth2kin_IDL_quit_helper();
    bool write(yarp::os::ConnectionWriter& connection) const override;
    bool read(yarp::os::ConnectionReader& connection) override;

    thread_local static bool s_return_helper;
};

thread_local bool depth2kin_IDL_quit_helper::s_return_helper = {};

depth2kin_IDL_quit_helper::depth2kin_IDL_quit_helper()
{
    s_return_helper = {};
}

bool depth2kin_IDL_quit_helper::write(yarp::os::ConnectionWriter& connection) const
{
    yarp::os::idl::WireWriter writer(connection);
    if (!writer.writeListHeader(1)) {
        return false;
    }
    if (!writer.writeTag("quit", 1, 1)) {
        return false;
    }
    return true;
}

bool depth2kin_IDL_quit_helper::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    if (!reader.readListReturn()) {
        return false;
    }
    if (!reader.readBool(s_return_helper)) {
        reader.fail();
        return false;
    }
    return true;
}

// Constructor
depth2kin_IDL::depth2kin_IDL()
{
    yarp().setOwner(*this);
}

std::int32_t depth2kin_IDL::getNumExperts()
{
    depth2kin_IDL_getNumExperts_helper helper{};
    if (!yarp().canWrite()) {
        yError("Missing server method '%s'?", "std::int32_t depth2kin_IDL::getNumExperts()");
    }
    bool ok = yarp().write(helper, helper);
    return ok ? depth2kin_IDL_getNumExperts_helper::s_return_helper : std::int32_t{};
}

bool depth2kin_IDL::clearExperts()
{
    depth2kin_IDL_clearExperts_helper helper{};
    if (!yarp().canWrite()) {
        yError("Missing server method '%s'?", "bool depth2kin_IDL::clearExperts()");
    }
    bool ok = yarp().write(helper, helper);
    return ok ? depth2kin_IDL_clearExperts_helper::s_return_helper : bool{};
}

bool depth2kin_IDL::load()
{
    depth2kin_IDL_load_helper helper{};
    if (!yarp().canWrite()) {
        yError("Missing server method '%s'?", "bool depth2kin_IDL::load()");
    }
    bool ok = yarp().write(helper, helper);
    return ok ? depth2kin_IDL_load_helper::s_return_helper : bool{};
}

bool depth2kin_IDL::save()
{
    depth2kin_IDL_save_helper helper{};
    if (!yarp().canWrite()) {
        yError("Missing server method '%s'?", "bool depth2kin_IDL::save()");
    }
    bool ok = yarp().write(helper, helper);
    return ok ? depth2kin_IDL_save_helper::s_return_helper : bool{};
}

bool depth2kin_IDL::log(const std::string& type)
{
    depth2kin_IDL_log_helper helper{type};
    if (!yarp().canWrite()) {
        yError("Missing server method '%s'?", "bool depth2kin_IDL::log(const std::string& type)");
    }
    bool ok = yarp().write(helper, helper);
    return ok ? depth2kin_IDL_log_helper::s_return_helper : bool{};
}

bool depth2kin_IDL::explore()
{
    depth2kin_IDL_explore_helper helper{};
    if (!yarp().canWrite()) {
        yError("Missing server method '%s'?", "bool depth2kin_IDL::explore()");
    }
    bool ok = yarp().write(helper, helper);
    return ok ? depth2kin_IDL_explore_helper::s_return_helper : bool{};
}

bool depth2kin_IDL::stop()
{
    depth2kin_IDL_stop_helper helper{};
    if (!yarp().canWrite()) {
        yError("Missing server method '%s'?", "bool depth2kin_IDL::stop()");
    }
    bool ok = yarp().write(helper, helper);
    return ok ? depth2kin_IDL_stop_helper::s_return_helper : bool{};
}

bool depth2kin_IDL::setMaxDist(const double max_dist)
{
    depth2kin_IDL_setMaxDist_helper helper{max_dist};
    if (!yarp().canWrite()) {
        yError("Missing server method '%s'?", "bool depth2kin_IDL::setMaxDist(const double max_dist)");
    }
    bool ok = yarp().write(helper, helper);
    return ok ? depth2kin_IDL_setMaxDist_helper::s_return_helper : bool{};
}

double depth2kin_IDL::getMaxDist()
{
    depth2kin_IDL_getMaxDist_helper helper{};
    if (!yarp().canWrite()) {
        yError("Missing server method '%s'?", "double depth2kin_IDL::getMaxDist()");
    }
    bool ok = yarp().write(helper, helper);
    return ok ? depth2kin_IDL_getMaxDist_helper::s_return_helper : double{};
}

bool depth2kin_IDL::setRoi(const std::int32_t side)
{
    depth2kin_IDL_setRoi_helper helper{side};
    if (!yarp().canWrite()) {
        yError("Missing server method '%s'?", "bool depth2kin_IDL::setRoi(const std::int32_t side)");
    }
    bool ok = yarp().write(helper, helper);
    return ok ? depth2kin_IDL_setRoi_helper::s_return_helper : bool{};
}

std::int32_t depth2kin_IDL::getRoi()
{
    depth2kin_IDL_getRoi_helper helper{};
    if (!yarp().canWrite()) {
        yError("Missing server method '%s'?", "std::int32_t depth2kin_IDL::getRoi()");
    }
    bool ok = yarp().write(helper, helper);
    return ok ? depth2kin_IDL_getRoi_helper::s_return_helper : std::int32_t{};
}

bool depth2kin_IDL::setBlockEyes(const double block_eyes)
{
    depth2kin_IDL_setBlockEyes_helper helper{block_eyes};
    if (!yarp().canWrite()) {
        yError("Missing server method '%s'?", "bool depth2kin_IDL::setBlockEyes(const double block_eyes)");
    }
    bool ok = yarp().write(helper, helper);
    return ok ? depth2kin_IDL_setBlockEyes_helper::s_return_helper : bool{};
}

double depth2kin_IDL::getBlockEyes()
{
    depth2kin_IDL_getBlockEyes_helper helper{};
    if (!yarp().canWrite()) {
        yError("Missing server method '%s'?", "double depth2kin_IDL::getBlockEyes()");
    }
    bool ok = yarp().write(helper, helper);
    return ok ? depth2kin_IDL_getBlockEyes_helper::s_return_helper : double{};
}

bool depth2kin_IDL::blockEyes()
{
    depth2kin_IDL_blockEyes_helper helper{};
    if (!yarp().canWrite()) {
        yError("Missing server method '%s'?", "bool depth2kin_IDL::blockEyes()");
    }
    bool ok = yarp().write(helper, helper);
    return ok ? depth2kin_IDL_blockEyes_helper::s_return_helper : bool{};
}

bool depth2kin_IDL::clearEyes()
{
    depth2kin_IDL_clearEyes_helper helper{};
    if (!yarp().canWrite()) {
        yError("Missing server method '%s'?", "bool depth2kin_IDL::clearEyes()");
    }
    bool ok = yarp().write(helper, helper);
    return ok ? depth2kin_IDL_clearEyes_helper::s_return_helper : bool{};
}

bool depth2kin_IDL::setArm(const std::string& arm)
{
    depth2kin_IDL_setArm_helper helper{arm};
    if (!yarp().canWrite()) {
        yError("Missing server method '%s'?", "bool depth2kin_IDL::setArm(const std::string& arm)");
    }
    bool ok = yarp().write(helper, helper);
    return ok ? depth2kin_IDL_setArm_helper::s_return_helper : bool{};
}

std::string depth2kin_IDL::getArm()
{
    depth2kin_IDL_getArm_helper helper{};
    if (!yarp().canWrite()) {
        yError("Missing server method '%s'?", "std::string depth2kin_IDL::getArm()");
    }
    bool ok = yarp().write(helper, helper);
    return ok ? depth2kin_IDL_getArm_helper::s_return_helper : std::string{};
}

bool depth2kin_IDL::setCalibrationType(const std::string& type, const std::string& extrapolation)
{
    depth2kin_IDL_setCalibrationType_helper helper{type, extrapolation};
    if (!yarp().canWrite()) {
        yError("Missing server method '%s'?", "bool depth2kin_IDL::setCalibrationType(const std::string& type, const std::string& extrapolation)");
    }
    bool ok = yarp().write(helper, helper);
    return ok ? depth2kin_IDL_setCalibrationType_helper::s_return_helper : bool{};
}

std::string depth2kin_IDL::getCalibrationType()
{
    depth2kin_IDL_getCalibrationType_helper helper{};
    if (!yarp().canWrite()) {
        yError("Missing server method '%s'?", "std::string depth2kin_IDL::getCalibrationType()");
    }
    bool ok = yarp().write(helper, helper);
    return ok ? depth2kin_IDL_getCalibrationType_helper::s_return_helper : std::string{};
}

yarp::os::Property depth2kin_IDL::calibrate(const bool rm_outliers)
{
    depth2kin_IDL_calibrate_helper helper{rm_outliers};
    if (!yarp().canWrite()) {
        yError("Missing server method '%s'?", "yarp::os::Property depth2kin_IDL::calibrate(const bool rm_outliers)");
    }
    bool ok = yarp().write(helper, helper);
    return ok ? depth2kin_IDL_calibrate_helper::s_return_helper : yarp::os::Property{};
}

bool depth2kin_IDL::pushCalibrator()
{
    depth2kin_IDL_pushCalibrator_helper helper{};
    if (!yarp().canWrite()) {
        yError("Missing server method '%s'?", "bool depth2kin_IDL::pushCalibrator()");
    }
    bool ok = yarp().write(helper, helper);
    return ok ? depth2kin_IDL_pushCalibrator_helper::s_return_helper : bool{};
}

bool depth2kin_IDL::setTouchWithExperts(const std::string& sw)
{
    depth2kin_IDL_setTouchWithExperts_helper helper{sw};
    if (!yarp().canWrite()) {
        yError("Missing server method '%s'?", "bool depth2kin_IDL::setTouchWithExperts(const std::string& sw)");
    }
    bool ok = yarp().write(helper, helper);
    return ok ? depth2kin_IDL_setTouchWithExperts_helper::s_return_helper : bool{};
}

std::string depth2kin_IDL::getTouchWithExperts()
{
    depth2kin_IDL_getTouchWithExperts_helper helper{};
    if (!yarp().canWrite()) {
        yError("Missing server method '%s'?", "std::string depth2kin_IDL::getTouchWithExperts()");
    }
    bool ok = yarp().write(helper, helper);
    return ok ? depth2kin_IDL_getTouchWithExperts_helper::s_return_helper : std::string{};
}

bool depth2kin_IDL::touch(const std::int32_t u, const std::int32_t v)
{
    depth2kin_IDL_touch_helper helper{u, v};
    if (!yarp().canWrite()) {
        yError("Missing server method '%s'?", "bool depth2kin_IDL::touch(const std::int32_t u, const std::int32_t v)");
    }
    bool ok = yarp().write(helper, helper);
    return ok ? depth2kin_IDL_touch_helper::s_return_helper : bool{};
}

PointReq depth2kin_IDL::getPoint(const std::string& arm, const double x, const double y, const double z)
{
    depth2kin_IDL_getPoint_helper helper{arm, x, y, z};
    if (!yarp().canWrite()) {
        yError("Missing server method '%s'?", "PointReq depth2kin_IDL::getPoint(const std::string& arm, const double x, const double y, const double z)");
    }
    bool ok = yarp().write(helper, helper);
    return ok ? depth2kin_IDL_getPoint_helper::s_return_helper : PointReq{};
}

std::vector<PointReq> depth2kin_IDL::getPoints(const std::string& arm, const std::vector<double>& coordinates)
{
    depth2kin_IDL_getPoints_helper helper{arm, coordinates};
    if (!yarp().canWrite()) {
        yError("Missing server method '%s'?", "std::vector<PointReq> depth2kin_IDL::getPoints(const std::string& arm, const std::vector<double>& coordinates)");
    }
    bool ok = yarp().write(helper, helper);
    return ok ? depth2kin_IDL_getPoints_helper::s_return_helper : std::vector<PointReq>{};
}

bool depth2kin_IDL::setExperiment(const std::string& exp, const std::string& v)
{
    depth2kin_IDL_setExperiment_helper helper{exp, v};
    if (!yarp().canWrite()) {
        yError("Missing server method '%s'?", "bool depth2kin_IDL::setExperiment(const std::string& exp, const std::string& v)");
    }
    bool ok = yarp().write(helper, helper);
    return ok ? depth2kin_IDL_setExperiment_helper::s_return_helper : bool{};
}

std::string depth2kin_IDL::getExperiment(const std::string& exp)
{
    depth2kin_IDL_getExperiment_helper helper{exp};
    if (!yarp().canWrite()) {
        yError("Missing server method '%s'?", "std::string depth2kin_IDL::getExperiment(const std::string& exp)");
    }
    bool ok = yarp().write(helper, helper);
    return ok ? depth2kin_IDL_getExperiment_helper::s_return_helper : std::string{};
}

yarp::sig::Vector depth2kin_IDL::getExtrinsics(const std::string& eye)
{
    depth2kin_IDL_getExtrinsics_helper helper{eye};
    if (!yarp().canWrite()) {
        yError("Missing server method '%s'?", "yarp::sig::Vector depth2kin_IDL::getExtrinsics(const std::string& eye)");
    }
    bool ok = yarp().write(helper, helper);
    return ok ? depth2kin_IDL_getExtrinsics_helper::s_return_helper : yarp::sig::Vector{};
}

bool depth2kin_IDL::resetExtrinsics(const std::string& eye)
{
    depth2kin_IDL_resetExtrinsics_helper helper{eye};
    if (!yarp().canWrite()) {
        yError("Missing server method '%s'?", "bool depth2kin_IDL::resetExtrinsics(const std::string& eye)");
    }
    bool ok = yarp().write(helper, helper);
    return ok ? depth2kin_IDL_resetExtrinsics_helper::s_return_helper : bool{};
}

bool depth2kin_IDL::setExplorationWait(const double wait)
{
    depth2kin_IDL_setExplorationWait_helper helper{wait};
    if (!yarp().canWrite()) {
        yError("Missing server method '%s'?", "bool depth2kin_IDL::setExplorationWait(const double wait)");
    }
    bool ok = yarp().write(helper, helper);
    return ok ? depth2kin_IDL_setExplorationWait_helper::s_return_helper : bool{};
}

double depth2kin_IDL::getExplorationWait()
{
    depth2kin_IDL_getExplorationWait_helper helper{};
    if (!yarp().canWrite()) {
        yError("Missing server method '%s'?", "double depth2kin_IDL::getExplorationWait()");
    }
    bool ok = yarp().write(helper, helper);
    return ok ? depth2kin_IDL_getExplorationWait_helper::s_return_helper : double{};
}

bool depth2kin_IDL::setExplorationInTargetTol(const double tol)
{
    depth2kin_IDL_setExplorationInTargetTol_helper helper{tol};
    if (!yarp().canWrite()) {
        yError("Missing server method '%s'?", "bool depth2kin_IDL::setExplorationInTargetTol(const double tol)");
    }
    bool ok = yarp().write(helper, helper);
    return ok ? depth2kin_IDL_setExplorationInTargetTol_helper::s_return_helper : bool{};
}

double depth2kin_IDL::getExplorationInTargetTol()
{
    depth2kin_IDL_getExplorationInTargetTol_helper helper{};
    if (!yarp().canWrite()) {
        yError("Missing server method '%s'?", "double depth2kin_IDL::getExplorationInTargetTol()");
    }
    bool ok = yarp().write(helper, helper);
    return ok ? depth2kin_IDL_getExplorationInTargetTol_helper::s_return_helper : double{};
}

bool depth2kin_IDL::setTouchInTargetTol(const double tol)
{
    depth2kin_IDL_setTouchInTargetTol_helper helper{tol};
    if (!yarp().canWrite()) {
        yError("Missing server method '%s'?", "bool depth2kin_IDL::setTouchInTargetTol(const double tol)");
    }
    bool ok = yarp().write(helper, helper);
    return ok ? depth2kin_IDL_setTouchInTargetTol_helper::s_return_helper : bool{};
}

double depth2kin_IDL::getTouchInTargetTol()
{
    depth2kin_IDL_getTouchInTargetTol_helper helper{};
    if (!yarp().canWrite()) {
        yError("Missing server method '%s'?", "double depth2kin_IDL::getTouchInTargetTol()");
    }
    bool ok = yarp().write(helper, helper);
    return ok ? depth2kin_IDL_getTouchInTargetTol_helper::s_return_helper : double{};
}

bool depth2kin_IDL::setExplorationSpace(const double cx, const double cy, const double cz, const double a, const double b)
{
    depth2kin_IDL_setExplorationSpace_helper helper{cx, cy, cz, a, b};
    if (!yarp().canWrite()) {
        yError("Missing server method '%s'?", "bool depth2kin_IDL::setExplorationSpace(const double cx, const double cy, const double cz, const double a, const double b)");
    }
    bool ok = yarp().write(helper, helper);
    return ok ? depth2kin_IDL_setExplorationSpace_helper::s_return_helper : bool{};
}

bool depth2kin_IDL::setExplorationSpaceDelta(const double dcx, const double dcy, const double dcz, const double da, const double db)
{
    depth2kin_IDL_setExplorationSpaceDelta_helper helper{dcx, dcy, dcz, da, db};
    if (!yarp().canWrite()) {
        yError("Missing server method '%s'?", "bool depth2kin_IDL::setExplorationSpaceDelta(const double dcx, const double dcy, const double dcz, const double da, const double db)");
    }
    bool ok = yarp().write(helper, helper);
    return ok ? depth2kin_IDL_setExplorationSpaceDelta_helper::s_return_helper : bool{};
}

yarp::os::Property depth2kin_IDL::getExplorationData()
{
    depth2kin_IDL_getExplorationData_helper helper{};
    if (!yarp().canWrite()) {
        yError("Missing server method '%s'?", "yarp::os::Property depth2kin_IDL::getExplorationData()");
    }
    bool ok = yarp().write(helper, helper);
    return ok ? depth2kin_IDL_getExplorationData_helper::s_return_helper : yarp::os::Property{};
}

bool depth2kin_IDL::clearExplorationData()
{
    depth2kin_IDL_clearExplorationData_helper helper{};
    if (!yarp().canWrite()) {
        yError("Missing server method '%s'?", "bool depth2kin_IDL::clearExplorationData()");
    }
    bool ok = yarp().write(helper, helper);
    return ok ? depth2kin_IDL_clearExplorationData_helper::s_return_helper : bool{};
}

bool depth2kin_IDL::posture(const std::string& type)
{
    depth2kin_IDL_posture_helper helper{type};
    if (!yarp().canWrite()) {
        yError("Missing server method '%s'?", "bool depth2kin_IDL::posture(const std::string& type)");
    }
    bool ok = yarp().write(helper, helper);
    return ok ? depth2kin_IDL_posture_helper::s_return_helper : bool{};
}

bool depth2kin_IDL::calibrateDepth()
{
    depth2kin_IDL_calibrateDepth_helper helper{};
    if (!yarp().canWrite()) {
        yError("Missing server method '%s'?", "bool depth2kin_IDL::calibrateDepth()");
    }
    bool ok = yarp().write(helper, helper);
    return ok ? depth2kin_IDL_calibrateDepth_helper::s_return_helper : bool{};
}

bool depth2kin_IDL::quit()
{
    depth2kin_IDL_quit_helper helper{};
    if (!yarp().canWrite()) {
        yError("Missing server method '%s'?", "bool depth2kin_IDL::quit()");
    }
    bool ok = yarp().write(helper, helper);
    return ok ? depth2kin_IDL_quit_helper::s_return_helper : bool{};
}

// help method
std::vector<std::string> depth2kin_IDL::help(const std::string& functionName)
{
    bool showAll = (functionName == "--all");
    std::vector<std::string> helpString;
    if (showAll) {
        helpString.emplace_back("*** Available commands:");
        helpString.emplace_back("getNumExperts");
        helpString.emplace_back("clearExperts");
        helpString.emplace_back("load");
        helpString.emplace_back("save");
        helpString.emplace_back("log");
        helpString.emplace_back("explore");
        helpString.emplace_back("stop");
        helpString.emplace_back("setMaxDist");
        helpString.emplace_back("getMaxDist");
        helpString.emplace_back("setRoi");
        helpString.emplace_back("getRoi");
        helpString.emplace_back("setBlockEyes");
        helpString.emplace_back("getBlockEyes");
        helpString.emplace_back("blockEyes");
        helpString.emplace_back("clearEyes");
        helpString.emplace_back("setArm");
        helpString.emplace_back("getArm");
        helpString.emplace_back("setCalibrationType");
        helpString.emplace_back("getCalibrationType");
        helpString.emplace_back("calibrate");
        helpString.emplace_back("pushCalibrator");
        helpString.emplace_back("setTouchWithExperts");
        helpString.emplace_back("getTouchWithExperts");
        helpString.emplace_back("touch");
        helpString.emplace_back("getPoint");
        helpString.emplace_back("getPoints");
        helpString.emplace_back("setExperiment");
        helpString.emplace_back("getExperiment");
        helpString.emplace_back("getExtrinsics");
        helpString.emplace_back("resetExtrinsics");
        helpString.emplace_back("setExplorationWait");
        helpString.emplace_back("getExplorationWait");
        helpString.emplace_back("setExplorationInTargetTol");
        helpString.emplace_back("getExplorationInTargetTol");
        helpString.emplace_back("setTouchInTargetTol");
        helpString.emplace_back("getTouchInTargetTol");
        helpString.emplace_back("setExplorationSpace");
        helpString.emplace_back("setExplorationSpaceDelta");
        helpString.emplace_back("getExplorationData");
        helpString.emplace_back("clearExplorationData");
        helpString.emplace_back("posture");
        helpString.emplace_back("calibrateDepth");
        helpString.emplace_back("quit");
        helpString.emplace_back("help");
    } else {
        if (functionName == "getNumExperts") {
            helpString.emplace_back("std::int32_t getNumExperts() ");
            helpString.emplace_back("Return the number of available experts. ");
            helpString.emplace_back("@return the number of available experts. ");
        }
        if (functionName == "clearExperts") {
            helpString.emplace_back("bool clearExperts() ");
            helpString.emplace_back("Clear the list of currently available experts. ");
            helpString.emplace_back("@return true/false on success/failure. ");
        }
        if (functionName == "load") {
            helpString.emplace_back("bool load() ");
            helpString.emplace_back("Reload the list of experts stored within the ");
            helpString.emplace_back("configuration file. ");
            helpString.emplace_back("@return true/false on success/failure. ");
        }
        if (functionName == "save") {
            helpString.emplace_back("bool save() ");
            helpString.emplace_back("Save the current list of experts into the ");
            helpString.emplace_back("configuration file. ");
            helpString.emplace_back("@return true/false on success/failure. ");
        }
        if (functionName == "log") {
            helpString.emplace_back("bool log(const std::string& type) ");
            helpString.emplace_back("Store on file the log of system response computed ");
            helpString.emplace_back("out of the explored set of input-output pairs. ");
            helpString.emplace_back("@param type can be \"experts\" or \"calibrator\", accounting either ");
            helpString.emplace_back("for the response of mixture of available experts or the output ");
            helpString.emplace_back("of the current calibrator, respectively. ");
            helpString.emplace_back("@return true/false on success/failure. It returns false also if ");
            helpString.emplace_back("\"calibrator\" is selected and calibration has not been performed yet. ");
            helpString.emplace_back("@note Each row of the file will contain the following data: \n ");
            helpString.emplace_back("\f$ d_x d_y d_z k_x k_y k_z r_x r_y r_z e, \f$ where \f$ d \f$ ");
            helpString.emplace_back("is the depth point, \f$ k \f$ is the kinematic point, \f$ r \f$ ");
            helpString.emplace_back("is the system response and \f$ e=|k-r| \f$ is the error. ");
        }
        if (functionName == "explore") {
            helpString.emplace_back("bool explore() ");
            helpString.emplace_back("Start the exploration phase. ");
            helpString.emplace_back("@return true/false on success/failure. ");
        }
        if (functionName == "stop") {
            helpString.emplace_back("bool stop() ");
            helpString.emplace_back("Yield an asynchronous stop of the exploration phase. ");
            helpString.emplace_back("@return true/false on success/failure. ");
        }
        if (functionName == "setMaxDist") {
            helpString.emplace_back("bool setMaxDist(const double max_dist) ");
            helpString.emplace_back("Set the maximum allowed distance between the depth point and ");
            helpString.emplace_back("kinematic prediction to enable data collection. ");
            helpString.emplace_back("@param max_dist the value in meters. ");
            helpString.emplace_back("@return true/false on success/failure. ");
        }
        if (functionName == "getMaxDist") {
            helpString.emplace_back("double getMaxDist() ");
            helpString.emplace_back("Return the maximum allowed distance between depth point and ");
            helpString.emplace_back("kinematic prediction to enable data collection. ");
            helpString.emplace_back("@return the distance. ");
        }
        if (functionName == "setRoi") {
            helpString.emplace_back("bool setRoi(const std::int32_t side) ");
            helpString.emplace_back("Set the side of the squared window used to filter data ");
            helpString.emplace_back("collection in the image plane. ");
            helpString.emplace_back("@param side the length of the window side. ");
            helpString.emplace_back("@return true/false on success/failure. ");
        }
        if (functionName == "getRoi") {
            helpString.emplace_back("std::int32_t getRoi() ");
            helpString.emplace_back("Return the side of the squared window used to filter data ");
            helpString.emplace_back("collection in the image plane. ");
            helpString.emplace_back("@return the window side. ");
        }
        if (functionName == "setBlockEyes") {
            helpString.emplace_back("bool setBlockEyes(const double block_eyes) ");
            helpString.emplace_back("Set the vergence angle used to keep the gaze fixed. ");
            helpString.emplace_back("@param block_eyes the value in degrees of the vergence. It must ");
            helpString.emplace_back("be equal or greater than the minimum vergence angle allowed ");
            helpString.emplace_back("by the gaze controller. ");
            helpString.emplace_back("@return true/false on success/failure. ");
        }
        if (functionName == "getBlockEyes") {
            helpString.emplace_back("double getBlockEyes() ");
            helpString.emplace_back("Return the current angle to keep the vergence at. ");
            helpString.emplace_back("@return the vergence angle in degrees. ");
        }
        if (functionName == "blockEyes") {
            helpString.emplace_back("bool blockEyes() ");
            helpString.emplace_back("Tell the gaze to immediately steer the eyes to the stored ");
            helpString.emplace_back("vergence angle and stay still. ");
            helpString.emplace_back("@return true/false on success/failure. ");
        }
        if (functionName == "clearEyes") {
            helpString.emplace_back("bool clearEyes() ");
            helpString.emplace_back("Remove the block on the eyes. ");
            helpString.emplace_back("@return true/false on success/failure. ");
        }
        if (functionName == "setArm") {
            helpString.emplace_back("bool setArm(const std::string& arm) ");
            helpString.emplace_back("Select the arm to deal with. ");
            helpString.emplace_back("@param arm is \"left\" or \"right\". ");
            helpString.emplace_back("@return true/false on success/failure. ");
        }
        if (functionName == "getArm") {
            helpString.emplace_back("std::string getArm() ");
            helpString.emplace_back("Return the current arm. ");
            helpString.emplace_back("@return \"left\" or \"right\". ");
        }
        if (functionName == "setCalibrationType") {
            helpString.emplace_back("bool setCalibrationType(const std::string& type, const std::string& extrapolation = \"auto\") ");
            helpString.emplace_back("Set up the calibrator type. ");
            helpString.emplace_back("@param type can be one of the following: \n ");
            helpString.emplace_back("\"se3\", \"se3+scale\", \"affine\", \"lssvm\". ");
            helpString.emplace_back("@param extrapolation specifies whether the calibrator will be ");
            helpString.emplace_back("used for extrapolating data (\"true\") or not (\"false\"); if \"auto\" ");
            helpString.emplace_back("is provided, then automatic choice is taken depending on the type. ");
            helpString.emplace_back("@return true/false on success/failure. ");
        }
        if (functionName == "getCalibrationType") {
            helpString.emplace_back("std::string getCalibrationType() ");
            helpString.emplace_back("Return the current calibration type. ");
            helpString.emplace_back("@return the calibration type. ");
        }
        if (functionName == "calibrate") {
            helpString.emplace_back("yarp::os::Property calibrate(const bool rm_outliers = 1) ");
            helpString.emplace_back("Ask the current calibrator to carry out the calibration. ");
            helpString.emplace_back("@param rm_outliers if true outliers removal is performed. ");
            helpString.emplace_back("@return a property containing the output in terms of ");
            helpString.emplace_back("calibration errors for each subsystem: \"calibrator\", \"aligner\". ");
        }
        if (functionName == "pushCalibrator") {
            helpString.emplace_back("bool pushCalibrator() ");
            helpString.emplace_back("Push the current calibrator in the list of experts. ");
            helpString.emplace_back("@return true/false on success/failure. ");
            helpString.emplace_back("@note the calibrator needs to have been calibrated at least once. ");
        }
        if (functionName == "setTouchWithExperts") {
            helpString.emplace_back("bool setTouchWithExperts(const std::string& sw) ");
            helpString.emplace_back("Enable/disable the use of experts for touch test. ");
            helpString.emplace_back("@param switch is \"on\"/\"off\" to use/not-use the experts. ");
            helpString.emplace_back("@return true/false on success/failure. ");
        }
        if (functionName == "getTouchWithExperts") {
            helpString.emplace_back("std::string getTouchWithExperts() ");
            helpString.emplace_back("Return the current status of the switch for experts usage ");
            helpString.emplace_back("during touch test. ");
            helpString.emplace_back("@return \"on\"/\"off\" if experts are used/not-used. ");
        }
        if (functionName == "touch") {
            helpString.emplace_back("bool touch(const std::int32_t u, const std::int32_t v) ");
            helpString.emplace_back("Yield a <i>touch</i> action with the finger on a depth point. ");
            helpString.emplace_back("@param u the u-coordinate of the depth point in the image plane. ");
            helpString.emplace_back("@param v the v-coordinate of the depth point in the image plane. ");
            helpString.emplace_back("@return true/false on success/failure. ");
        }
        if (functionName == "getPoint") {
            helpString.emplace_back("PointReq getPoint(const std::string& arm, const double x, const double y, const double z) ");
            helpString.emplace_back("Retrieve the compensated kinematic point corresponding to the input ");
            helpString.emplace_back("depth point. ");
            helpString.emplace_back("@param arm accounts for \"left\" or \"right\" list of experts. ");
            helpString.emplace_back("@param x the x-coordinate of the depth point. ");
            helpString.emplace_back("@param y the y-coordinate of the depth point. ");
            helpString.emplace_back("@param z the z-coordinate of the depth point. ");
            helpString.emplace_back("@return the requested point in \ref PointReq format. ");
        }
        if (functionName == "getPoints") {
            helpString.emplace_back("std::vector<PointReq> getPoints(const std::string& arm, const std::vector<double>& coordinates) ");
            helpString.emplace_back("Retrieve the compensated kinematic points corresponding to the input ");
            helpString.emplace_back("depth points. ");
            helpString.emplace_back("@param arm accounts for \"left\" or \"right\" list of experts. ");
            helpString.emplace_back("@param coordinates the 3D coordinates of the depth points. ");
            helpString.emplace_back("@return the requested points in \ref PointReq format. ");
        }
        if (functionName == "setExperiment") {
            helpString.emplace_back("bool setExperiment(const std::string& exp, const std::string& v) ");
            helpString.emplace_back("Set on/off an experiment. ");
            helpString.emplace_back("@param exp the experiment (\"depth2kin\" or \"aligneyes\") to switch on/off. ");
            helpString.emplace_back("@param v is \"on\" or \"off\". ");
            helpString.emplace_back("@return true/false on success/failure. ");
        }
        if (functionName == "getExperiment") {
            helpString.emplace_back("std::string getExperiment(const std::string& exp) ");
            helpString.emplace_back("Return the current status of the experiment. ");
            helpString.emplace_back("@param exp the experiment (\"depth2kin\" or \"aligneyes\") ");
            helpString.emplace_back("@return \"on\"/\"off\". ");
        }
        if (functionName == "getExtrinsics") {
            helpString.emplace_back("yarp::sig::Vector getExtrinsics(const std::string& eye) ");
            helpString.emplace_back("Retrieve the current extrinsics camera parameters. ");
            helpString.emplace_back("@param eye is \"left\" or \"right\" camera eye. ");
            helpString.emplace_back("@return a 6x1 Vector containing the translational and the ");
            helpString.emplace_back("rotational (in roll-pith-yaw convention) parts of the ");
            helpString.emplace_back("extrinsics matrix. ");
        }
        if (functionName == "resetExtrinsics") {
            helpString.emplace_back("bool resetExtrinsics(const std::string& eye) ");
            helpString.emplace_back("Reset the extrinsics matrix to default eye matrix. ");
            helpString.emplace_back("@param eye is \"left\" or \"right\" camera eye. ");
            helpString.emplace_back("@return true/false on success/failure. ");
        }
        if (functionName == "setExplorationWait") {
            helpString.emplace_back("bool setExplorationWait(const double wait) ");
            helpString.emplace_back("Set up the wait timeout used during exploration between ");
            helpString.emplace_back("two consecutive data points. ");
            helpString.emplace_back("@param wait the timeout in seconds. ");
            helpString.emplace_back("@return true/false on success/failure. ");
        }
        if (functionName == "getExplorationWait") {
            helpString.emplace_back("double getExplorationWait() ");
            helpString.emplace_back("Return the current wait timeout used during exploration ");
            helpString.emplace_back("between two consecutive data points. ");
            helpString.emplace_back("@return the wait timeout in seconds. ");
        }
        if (functionName == "setExplorationInTargetTol") {
            helpString.emplace_back("bool setExplorationInTargetTol(const double tol) ");
            helpString.emplace_back("Set up the cartesian tolerance used during exploration. ");
            helpString.emplace_back("@param tol the overall tolerance employed for the ");
            helpString.emplace_back("cartesian movements. ");
            helpString.emplace_back("@return true/false on success/failure. ");
        }
        if (functionName == "getExplorationInTargetTol") {
            helpString.emplace_back("double getExplorationInTargetTol() ");
            helpString.emplace_back("Return the current cartesian tolerance used ");
            helpString.emplace_back("during exploration. ");
            helpString.emplace_back("@return the tolerance. ");
        }
        if (functionName == "setTouchInTargetTol") {
            helpString.emplace_back("bool setTouchInTargetTol(const double tol) ");
            helpString.emplace_back("Set up the cartesian tolerance used during a touch actions. ");
            helpString.emplace_back("@param tol the overall tolerance employed for the ");
            helpString.emplace_back("cartesian movements. ");
            helpString.emplace_back("@return true/false on success/failure. ");
        }
        if (functionName == "getTouchInTargetTol") {
            helpString.emplace_back("double getTouchInTargetTol() ");
            helpString.emplace_back("Return the current cartesian tolerance used ");
            helpString.emplace_back("during touch actions. ");
            helpString.emplace_back("@return the tolerance. ");
        }
        if (functionName == "setExplorationSpace") {
            helpString.emplace_back("bool setExplorationSpace(const double cx, const double cy, const double cz, const double a, const double b) ");
            helpString.emplace_back("Set up the internally coded exploration space composed by ");
            helpString.emplace_back("two co-centered ellipses, one orthogonal to other, and defined ");
            helpString.emplace_back("by means of the center and the two semi-axes. ");
            helpString.emplace_back("@param cx the center x-coordinate. ");
            helpString.emplace_back("@param cy the center y-coordinate. ");
            helpString.emplace_back("@param cz the center z-coordiante. ");
            helpString.emplace_back("@param a the major semi-axis length. ");
            helpString.emplace_back("@param b the minor semi-axis length. ");
            helpString.emplace_back("@return true/false on success/failure. ");
        }
        if (functionName == "setExplorationSpaceDelta") {
            helpString.emplace_back("bool setExplorationSpaceDelta(const double dcx = 0, const double dcy = 0, const double dcz = 0, const double da = 0, const double db = 0) ");
            helpString.emplace_back("Set up the exploration space in terms of differences with respect ");
            helpString.emplace_back("to the internally coded couple of ellipses. ");
            helpString.emplace_back("@param dcx the center delta x-coordinate. ");
            helpString.emplace_back("@param dcy the center delta y-coordinate. ");
            helpString.emplace_back("@param dcz the center delta z-coordiante. ");
            helpString.emplace_back("@param da the major semi-axis delta length. ");
            helpString.emplace_back("@param db the minor semi-axis delta length. ");
            helpString.emplace_back("@return true/false on success/failure. ");
        }
        if (functionName == "getExplorationData") {
            helpString.emplace_back("yarp::os::Property getExplorationData() ");
            helpString.emplace_back("Return some progress about the ongoing exploration. ");
            helpString.emplace_back("@return a property that looks like ");
            helpString.emplace_back("(\"status\" [\"idle\"|\"ongoing\"]) (\"total_points\" <int>) (\"remaining_points\" <int>) ");
            helpString.emplace_back("(\"calibrator_points\" <int>) (\"aligner_points\" <int>) ");
        }
        if (functionName == "clearExplorationData") {
            helpString.emplace_back("bool clearExplorationData() ");
            helpString.emplace_back("Clean up the internal list of explored points pairs. ");
            helpString.emplace_back("@return true/false on success/failure. ");
        }
        if (functionName == "posture") {
            helpString.emplace_back("bool posture(const std::string& type) ");
            helpString.emplace_back("Make the robot reach a predefined posture. ");
            helpString.emplace_back("@param type can be one of the following: \n ");
            helpString.emplace_back("\"home\", \"look_hands\". ");
            helpString.emplace_back("@return true/false on success/failure. ");
        }
        if (functionName == "calibrateDepth") {
            helpString.emplace_back("bool calibrateDepth() ");
            helpString.emplace_back("Put the robot in a suitable predefined posture ");
            helpString.emplace_back("and then execute depth calibration. ");
            helpString.emplace_back("@return true/false on success/failure. ");
        }
        if (functionName == "quit") {
            helpString.emplace_back("bool quit() ");
            helpString.emplace_back("Quit the module. ");
            helpString.emplace_back("@return true/false on success/failure. ");
        }
        if (functionName == "help") {
            helpString.emplace_back("std::vector<std::string> help(const std::string& functionName = \"--all\")");
            helpString.emplace_back("Return list of available commands, or help message for a specific function");
            helpString.emplace_back("@param functionName name of command for which to get a detailed description. If none or '--all' is provided, print list of available commands");
            helpString.emplace_back("@return list of strings (one string per line)");
        }
    }
    if (helpString.empty()) {
        helpString.emplace_back("Command not found");
    }
    return helpString;
}

// read from ConnectionReader
bool depth2kin_IDL::read(yarp::os::ConnectionReader& connection)
{
    yarp::os::idl::WireReader reader(connection);
    reader.expectAccept();
    if (!reader.readListHeader()) {
        reader.fail();
        return false;
    }

    std::string tag = reader.readTag();
    bool direct = (tag == "__direct__");
    if (direct) {
        tag = reader.readTag();
    }
    while (!reader.isError()) {
        if (tag == "getNumExperts") {
            depth2kin_IDL_getNumExperts_helper::s_return_helper = getNumExperts();
            yarp::os::idl::WireWriter writer(reader);
            if (!writer.isNull()) {
                if (!writer.writeListHeader(1)) {
                    return false;
                }
                if (!writer.writeI32(depth2kin_IDL_getNumExperts_helper::s_return_helper)) {
                    return false;
                }
            }
            reader.accept();
            return true;
        }
        if (tag == "clearExperts") {
            depth2kin_IDL_clearExperts_helper::s_return_helper = clearExperts();
            yarp::os::idl::WireWriter writer(reader);
            if (!writer.isNull()) {
                if (!writer.writeListHeader(1)) {
                    return false;
                }
                if (!writer.writeBool(depth2kin_IDL_clearExperts_helper::s_return_helper)) {
                    return false;
                }
            }
            reader.accept();
            return true;
        }
        if (tag == "load") {
            depth2kin_IDL_load_helper::s_return_helper = load();
            yarp::os::idl::WireWriter writer(reader);
            if (!writer.isNull()) {
                if (!writer.writeListHeader(1)) {
                    return false;
                }
                if (!writer.writeBool(depth2kin_IDL_load_helper::s_return_helper)) {
                    return false;
                }
            }
            reader.accept();
            return true;
        }
        if (tag == "save") {
            depth2kin_IDL_save_helper::s_return_helper = save();
            yarp::os::idl::WireWriter writer(reader);
            if (!writer.isNull()) {
                if (!writer.writeListHeader(1)) {
                    return false;
                }
                if (!writer.writeBool(depth2kin_IDL_save_helper::s_return_helper)) {
                    return false;
                }
            }
            reader.accept();
            return true;
        }
        if (tag == "log") {
            std::string type;
            if (!reader.readString(type)) {
                reader.fail();
                return false;
            }
            depth2kin_IDL_log_helper::s_return_helper = log(type);
            yarp::os::idl::WireWriter writer(reader);
            if (!writer.isNull()) {
                if (!writer.writeListHeader(1)) {
                    return false;
                }
                if (!writer.writeBool(depth2kin_IDL_log_helper::s_return_helper)) {
                    return false;
                }
            }
            reader.accept();
            return true;
        }
        if (tag == "explore") {
            depth2kin_IDL_explore_helper::s_return_helper = explore();
            yarp::os::idl::WireWriter writer(reader);
            if (!writer.isNull()) {
                if (!writer.writeListHeader(1)) {
                    return false;
                }
                if (!writer.writeBool(depth2kin_IDL_explore_helper::s_return_helper)) {
                    return false;
                }
            }
            reader.accept();
            return true;
        }
        if (tag == "stop") {
            depth2kin_IDL_stop_helper::s_return_helper = stop();
            yarp::os::idl::WireWriter writer(reader);
            if (!writer.isNull()) {
                if (!writer.writeListHeader(1)) {
                    return false;
                }
                if (!writer.writeBool(depth2kin_IDL_stop_helper::s_return_helper)) {
                    return false;
                }
            }
            reader.accept();
            return true;
        }
        if (tag == "setMaxDist") {
            double max_dist;
            if (!reader.readFloat64(max_dist)) {
                reader.fail();
                return false;
            }
            depth2kin_IDL_setMaxDist_helper::s_return_helper = setMaxDist(max_dist);
            yarp::os::idl::WireWriter writer(reader);
            if (!writer.isNull()) {
                if (!writer.writeListHeader(1)) {
                    return false;
                }
                if (!writer.writeBool(depth2kin_IDL_setMaxDist_helper::s_return_helper)) {
                    return false;
                }
            }
            reader.accept();
            return true;
        }
        if (tag == "getMaxDist") {
            depth2kin_IDL_getMaxDist_helper::s_return_helper = getMaxDist();
            yarp::os::idl::WireWriter writer(reader);
            if (!writer.isNull()) {
                if (!writer.writeListHeader(1)) {
                    return false;
                }
                if (!writer.writeFloat64(depth2kin_IDL_getMaxDist_helper::s_return_helper)) {
                    return false;
                }
            }
            reader.accept();
            return true;
        }
        if (tag == "setRoi") {
            std::int32_t side;
            if (!reader.readI32(side)) {
                reader.fail();
                return false;
            }
            depth2kin_IDL_setRoi_helper::s_return_helper = setRoi(side);
            yarp::os::idl::WireWriter writer(reader);
            if (!writer.isNull()) {
                if (!writer.writeListHeader(1)) {
                    return false;
                }
                if (!writer.writeBool(depth2kin_IDL_setRoi_helper::s_return_helper)) {
                    return false;
                }
            }
            reader.accept();
            return true;
        }
        if (tag == "getRoi") {
            depth2kin_IDL_getRoi_helper::s_return_helper = getRoi();
            yarp::os::idl::WireWriter writer(reader);
            if (!writer.isNull()) {
                if (!writer.writeListHeader(1)) {
                    return false;
                }
                if (!writer.writeI32(depth2kin_IDL_getRoi_helper::s_return_helper)) {
                    return false;
                }
            }
            reader.accept();
            return true;
        }
        if (tag == "setBlockEyes") {
            double block_eyes;
            if (!reader.readFloat64(block_eyes)) {
                reader.fail();
                return false;
            }
            depth2kin_IDL_setBlockEyes_helper::s_return_helper = setBlockEyes(block_eyes);
            yarp::os::idl::WireWriter writer(reader);
            if (!writer.isNull()) {
                if (!writer.writeListHeader(1)) {
                    return false;
                }
                if (!writer.writeBool(depth2kin_IDL_setBlockEyes_helper::s_return_helper)) {
                    return false;
                }
            }
            reader.accept();
            return true;
        }
        if (tag == "getBlockEyes") {
            depth2kin_IDL_getBlockEyes_helper::s_return_helper = getBlockEyes();
            yarp::os::idl::WireWriter writer(reader);
            if (!writer.isNull()) {
                if (!writer.writeListHeader(1)) {
                    return false;
                }
                if (!writer.writeFloat64(depth2kin_IDL_getBlockEyes_helper::s_return_helper)) {
                    return false;
                }
            }
            reader.accept();
            return true;
        }
        if (tag == "blockEyes") {
            depth2kin_IDL_blockEyes_helper::s_return_helper = blockEyes();
            yarp::os::idl::WireWriter writer(reader);
            if (!writer.isNull()) {
                if (!writer.writeListHeader(1)) {
                    return false;
                }
                if (!writer.writeBool(depth2kin_IDL_blockEyes_helper::s_return_helper)) {
                    return false;
                }
            }
            reader.accept();
            return true;
        }
        if (tag == "clearEyes") {
            depth2kin_IDL_clearEyes_helper::s_return_helper = clearEyes();
            yarp::os::idl::WireWriter writer(reader);
            if (!writer.isNull()) {
                if (!writer.writeListHeader(1)) {
                    return false;
                }
                if (!writer.writeBool(depth2kin_IDL_clearEyes_helper::s_return_helper)) {
                    return false;
                }
            }
            reader.accept();
            return true;
        }
        if (tag == "setArm") {
            std::string arm;
            if (!reader.readString(arm)) {
                reader.fail();
                return false;
            }
            depth2kin_IDL_setArm_helper::s_return_helper = setArm(arm);
            yarp::os::idl::WireWriter writer(reader);
            if (!writer.isNull()) {
                if (!writer.writeListHeader(1)) {
                    return false;
                }
                if (!writer.writeBool(depth2kin_IDL_setArm_helper::s_return_helper)) {
                    return false;
                }
            }
            reader.accept();
            return true;
        }
        if (tag == "getArm") {
            depth2kin_IDL_getArm_helper::s_return_helper = getArm();
            yarp::os::idl::WireWriter writer(reader);
            if (!writer.isNull()) {
                if (!writer.writeListHeader(1)) {
                    return false;
                }
                if (!writer.writeString(depth2kin_IDL_getArm_helper::s_return_helper)) {
                    return false;
                }
            }
            reader.accept();
            return true;
        }
        if (tag == "setCalibrationType") {
            std::string type;
            std::string extrapolation;
            if (!reader.readString(type)) {
                reader.fail();
                return false;
            }
            if (!reader.readString(extrapolation)) {
                extrapolation = "auto";
            }
            depth2kin_IDL_setCalibrationType_helper::s_return_helper = setCalibrationType(type, extrapolation);
            yarp::os::idl::WireWriter writer(reader);
            if (!writer.isNull()) {
                if (!writer.writeListHeader(1)) {
                    return false;
                }
                if (!writer.writeBool(depth2kin_IDL_setCalibrationType_helper::s_return_helper)) {
                    return false;
                }
            }
            reader.accept();
            return true;
        }
        if (tag == "getCalibrationType") {
            depth2kin_IDL_getCalibrationType_helper::s_return_helper = getCalibrationType();
            yarp::os::idl::WireWriter writer(reader);
            if (!writer.isNull()) {
                if (!writer.writeListHeader(1)) {
                    return false;
                }
                if (!writer.writeString(depth2kin_IDL_getCalibrationType_helper::s_return_helper)) {
                    return false;
                }
            }
            reader.accept();
            return true;
        }
        if (tag == "calibrate") {
            bool rm_outliers;
            if (!reader.readBool(rm_outliers)) {
                rm_outliers = 1;
            }
            depth2kin_IDL_calibrate_helper::s_return_helper = calibrate(rm_outliers);
            yarp::os::idl::WireWriter writer(reader);
            if (!writer.isNull()) {
                if (!writer.writeListHeader(1)) {
                    return false;
                }
                if (!writer.write(depth2kin_IDL_calibrate_helper::s_return_helper)) {
                    return false;
                }
            }
            reader.accept();
            return true;
        }
        if (tag == "pushCalibrator") {
            depth2kin_IDL_pushCalibrator_helper::s_return_helper = pushCalibrator();
            yarp::os::idl::WireWriter writer(reader);
            if (!writer.isNull()) {
                if (!writer.writeListHeader(1)) {
                    return false;
                }
                if (!writer.writeBool(depth2kin_IDL_pushCalibrator_helper::s_return_helper)) {
                    return false;
                }
            }
            reader.accept();
            return true;
        }
        if (tag == "setTouchWithExperts") {
            std::string sw;
            if (!reader.readString(sw)) {
                reader.fail();
                return false;
            }
            depth2kin_IDL_setTouchWithExperts_helper::s_return_helper = setTouchWithExperts(sw);
            yarp::os::idl::WireWriter writer(reader);
            if (!writer.isNull()) {
                if (!writer.writeListHeader(1)) {
                    return false;
                }
                if (!writer.writeBool(depth2kin_IDL_setTouchWithExperts_helper::s_return_helper)) {
                    return false;
                }
            }
            reader.accept();
            return true;
        }
        if (tag == "getTouchWithExperts") {
            depth2kin_IDL_getTouchWithExperts_helper::s_return_helper = getTouchWithExperts();
            yarp::os::idl::WireWriter writer(reader);
            if (!writer.isNull()) {
                if (!writer.writeListHeader(1)) {
                    return false;
                }
                if (!writer.writeString(depth2kin_IDL_getTouchWithExperts_helper::s_return_helper)) {
                    return false;
                }
            }
            reader.accept();
            return true;
        }
        if (tag == "touch") {
            std::int32_t u;
            std::int32_t v;
            if (!reader.readI32(u)) {
                reader.fail();
                return false;
            }
            if (!reader.readI32(v)) {
                reader.fail();
                return false;
            }
            depth2kin_IDL_touch_helper::s_return_helper = touch(u, v);
            yarp::os::idl::WireWriter writer(reader);
            if (!writer.isNull()) {
                if (!writer.writeListHeader(1)) {
                    return false;
                }
                if (!writer.writeBool(depth2kin_IDL_touch_helper::s_return_helper)) {
                    return false;
                }
            }
            reader.accept();
            return true;
        }
        if (tag == "getPoint") {
            std::string arm;
            double x;
            double y;
            double z;
            if (!reader.readString(arm)) {
                reader.fail();
                return false;
            }
            if (!reader.readFloat64(x)) {
                reader.fail();
                return false;
            }
            if (!reader.readFloat64(y)) {
                reader.fail();
                return false;
            }
            if (!reader.readFloat64(z)) {
                reader.fail();
                return false;
            }
            depth2kin_IDL_getPoint_helper::s_return_helper = getPoint(arm, x, y, z);
            yarp::os::idl::WireWriter writer(reader);
            if (!writer.isNull()) {
                if (!writer.writeListHeader(4)) {
                    return false;
                }
                if (!writer.write(depth2kin_IDL_getPoint_helper::s_return_helper)) {
                    return false;
                }
            }
            reader.accept();
            return true;
        }
        if (tag == "getPoints") {
            std::string arm;
            std::vector<double> coordinates;
            if (!reader.readString(arm)) {
                reader.fail();
                return false;
            }
            coordinates.clear();
            uint32_t _size6;
            yarp::os::idl::WireState _etype9;
            reader.readListBegin(_etype9, _size6);
            coordinates.resize(_size6);
            for (size_t _i10 = 0; _i10 < _size6; ++_i10) {
                if (!reader.readFloat64(coordinates[_i10])) {
                    reader.fail();
                    return false;
                }
            }
            reader.readListEnd();
            depth2kin_IDL_getPoints_helper::s_return_helper = getPoints(arm, coordinates);
            yarp::os::idl::WireWriter writer(reader);
            if (!writer.isNull()) {
                if (!writer.writeListHeader(1)) {
                    return false;
                }
                if (!writer.writeListBegin(BOTTLE_TAG_LIST, static_cast<uint32_t>(depth2kin_IDL_getPoints_helper::s_return_helper.size()))) {
                    return false;
                }
                for (const auto& _item11 : depth2kin_IDL_getPoints_helper::s_return_helper) {
                    if (!writer.writeNested(_item11)) {
                        return false;
                    }
                }
                if (!writer.writeListEnd()) {
                    return false;
                }
            }
            reader.accept();
            return true;
        }
        if (tag == "setExperiment") {
            std::string exp;
            std::string v;
            if (!reader.readString(exp)) {
                reader.fail();
                return false;
            }
            if (!reader.readString(v)) {
                reader.fail();
                return false;
            }
            depth2kin_IDL_setExperiment_helper::s_return_helper = setExperiment(exp, v);
            yarp::os::idl::WireWriter writer(reader);
            if (!writer.isNull()) {
                if (!writer.writeListHeader(1)) {
                    return false;
                }
                if (!writer.writeBool(depth2kin_IDL_setExperiment_helper::s_return_helper)) {
                    return false;
                }
            }
            reader.accept();
            return true;
        }
        if (tag == "getExperiment") {
            std::string exp;
            if (!reader.readString(exp)) {
                reader.fail();
                return false;
            }
            depth2kin_IDL_getExperiment_helper::s_return_helper = getExperiment(exp);
            yarp::os::idl::WireWriter writer(reader);
            if (!writer.isNull()) {
                if (!writer.writeListHeader(1)) {
                    return false;
                }
                if (!writer.writeString(depth2kin_IDL_getExperiment_helper::s_return_helper)) {
                    return false;
                }
            }
            reader.accept();
            return true;
        }
        if (tag == "getExtrinsics") {
            std::string eye;
            if (!reader.readString(eye)) {
                reader.fail();
                return false;
            }
            depth2kin_IDL_getExtrinsics_helper::s_return_helper = getExtrinsics(eye);
            yarp::os::idl::WireWriter writer(reader);
            if (!writer.isNull()) {
                if (!writer.writeListHeader(1)) {
                    return false;
                }
                if (!writer.write(depth2kin_IDL_getExtrinsics_helper::s_return_helper)) {
                    return false;
                }
            }
            reader.accept();
            return true;
        }
        if (tag == "resetExtrinsics") {
            std::string eye;
            if (!reader.readString(eye)) {
                reader.fail();
                return false;
            }
            depth2kin_IDL_resetExtrinsics_helper::s_return_helper = resetExtrinsics(eye);
            yarp::os::idl::WireWriter writer(reader);
            if (!writer.isNull()) {
                if (!writer.writeListHeader(1)) {
                    return false;
                }
                if (!writer.writeBool(depth2kin_IDL_resetExtrinsics_helper::s_return_helper)) {
                    return false;
                }
            }
            reader.accept();
            return true;
        }
        if (tag == "setExplorationWait") {
            double wait;
            if (!reader.readFloat64(wait)) {
                reader.fail();
                return false;
            }
            depth2kin_IDL_setExplorationWait_helper::s_return_helper = setExplorationWait(wait);
            yarp::os::idl::WireWriter writer(reader);
            if (!writer.isNull()) {
                if (!writer.writeListHeader(1)) {
                    return false;
                }
                if (!writer.writeBool(depth2kin_IDL_setExplorationWait_helper::s_return_helper)) {
                    return false;
                }
            }
            reader.accept();
            return true;
        }
        if (tag == "getExplorationWait") {
            depth2kin_IDL_getExplorationWait_helper::s_return_helper = getExplorationWait();
            yarp::os::idl::WireWriter writer(reader);
            if (!writer.isNull()) {
                if (!writer.writeListHeader(1)) {
                    return false;
                }
                if (!writer.writeFloat64(depth2kin_IDL_getExplorationWait_helper::s_return_helper)) {
                    return false;
                }
            }
            reader.accept();
            return true;
        }
        if (tag == "setExplorationInTargetTol") {
            double tol;
            if (!reader.readFloat64(tol)) {
                reader.fail();
                return false;
            }
            depth2kin_IDL_setExplorationInTargetTol_helper::s_return_helper = setExplorationInTargetTol(tol);
            yarp::os::idl::WireWriter writer(reader);
            if (!writer.isNull()) {
                if (!writer.writeListHeader(1)) {
                    return false;
                }
                if (!writer.writeBool(depth2kin_IDL_setExplorationInTargetTol_helper::s_return_helper)) {
                    return false;
                }
            }
            reader.accept();
            return true;
        }
        if (tag == "getExplorationInTargetTol") {
            depth2kin_IDL_getExplorationInTargetTol_helper::s_return_helper = getExplorationInTargetTol();
            yarp::os::idl::WireWriter writer(reader);
            if (!writer.isNull()) {
                if (!writer.writeListHeader(1)) {
                    return false;
                }
                if (!writer.writeFloat64(depth2kin_IDL_getExplorationInTargetTol_helper::s_return_helper)) {
                    return false;
                }
            }
            reader.accept();
            return true;
        }
        if (tag == "setTouchInTargetTol") {
            double tol;
            if (!reader.readFloat64(tol)) {
                reader.fail();
                return false;
            }
            depth2kin_IDL_setTouchInTargetTol_helper::s_return_helper = setTouchInTargetTol(tol);
            yarp::os::idl::WireWriter writer(reader);
            if (!writer.isNull()) {
                if (!writer.writeListHeader(1)) {
                    return false;
                }
                if (!writer.writeBool(depth2kin_IDL_setTouchInTargetTol_helper::s_return_helper)) {
                    return false;
                }
            }
            reader.accept();
            return true;
        }
        if (tag == "getTouchInTargetTol") {
            depth2kin_IDL_getTouchInTargetTol_helper::s_return_helper = getTouchInTargetTol();
            yarp::os::idl::WireWriter writer(reader);
            if (!writer.isNull()) {
                if (!writer.writeListHeader(1)) {
                    return false;
                }
                if (!writer.writeFloat64(depth2kin_IDL_getTouchInTargetTol_helper::s_return_helper)) {
                    return false;
                }
            }
            reader.accept();
            return true;
        }
        if (tag == "setExplorationSpace") {
            double cx;
            double cy;
            double cz;
            double a;
            double b;
            if (!reader.readFloat64(cx)) {
                reader.fail();
                return false;
            }
            if (!reader.readFloat64(cy)) {
                reader.fail();
                return false;
            }
            if (!reader.readFloat64(cz)) {
                reader.fail();
                return false;
            }
            if (!reader.readFloat64(a)) {
                reader.fail();
                return false;
            }
            if (!reader.readFloat64(b)) {
                reader.fail();
                return false;
            }
            depth2kin_IDL_setExplorationSpace_helper::s_return_helper = setExplorationSpace(cx, cy, cz, a, b);
            yarp::os::idl::WireWriter writer(reader);
            if (!writer.isNull()) {
                if (!writer.writeListHeader(1)) {
                    return false;
                }
                if (!writer.writeBool(depth2kin_IDL_setExplorationSpace_helper::s_return_helper)) {
                    return false;
                }
            }
            reader.accept();
            return true;
        }
        if (tag == "setExplorationSpaceDelta") {
            double dcx;
            double dcy;
            double dcz;
            double da;
            double db;
            if (!reader.readFloat64(dcx)) {
                dcx = 0;
            }
            if (!reader.readFloat64(dcy)) {
                dcy = 0;
            }
            if (!reader.readFloat64(dcz)) {
                dcz = 0;
            }
            if (!reader.readFloat64(da)) {
                da = 0;
            }
            if (!reader.readFloat64(db)) {
                db = 0;
            }
            depth2kin_IDL_setExplorationSpaceDelta_helper::s_return_helper = setExplorationSpaceDelta(dcx, dcy, dcz, da, db);
            yarp::os::idl::WireWriter writer(reader);
            if (!writer.isNull()) {
                if (!writer.writeListHeader(1)) {
                    return false;
                }
                if (!writer.writeBool(depth2kin_IDL_setExplorationSpaceDelta_helper::s_return_helper)) {
                    return false;
                }
            }
            reader.accept();
            return true;
        }
        if (tag == "getExplorationData") {
            depth2kin_IDL_getExplorationData_helper::s_return_helper = getExplorationData();
            yarp::os::idl::WireWriter writer(reader);
            if (!writer.isNull()) {
                if (!writer.writeListHeader(1)) {
                    return false;
                }
                if (!writer.write(depth2kin_IDL_getExplorationData_helper::s_return_helper)) {
                    return false;
                }
            }
            reader.accept();
            return true;
        }
        if (tag == "clearExplorationData") {
            depth2kin_IDL_clearExplorationData_helper::s_return_helper = clearExplorationData();
            yarp::os::idl::WireWriter writer(reader);
            if (!writer.isNull()) {
                if (!writer.writeListHeader(1)) {
                    return false;
                }
                if (!writer.writeBool(depth2kin_IDL_clearExplorationData_helper::s_return_helper)) {
                    return false;
                }
            }
            reader.accept();
            return true;
        }
        if (tag == "posture") {
            std::string type;
            if (!reader.readString(type)) {
                reader.fail();
                return false;
            }
            depth2kin_IDL_posture_helper::s_return_helper = posture(type);
            yarp::os::idl::WireWriter writer(reader);
            if (!writer.isNull()) {
                if (!writer.writeListHeader(1)) {
                    return false;
                }
                if (!writer.writeBool(depth2kin_IDL_posture_helper::s_return_helper)) {
                    return false;
                }
            }
            reader.accept();
            return true;
        }
        if (tag == "calibrateDepth") {
            depth2kin_IDL_calibrateDepth_helper::s_return_helper = calibrateDepth();
            yarp::os::idl::WireWriter writer(reader);
            if (!writer.isNull()) {
                if (!writer.writeListHeader(1)) {
                    return false;
                }
                if (!writer.writeBool(depth2kin_IDL_calibrateDepth_helper::s_return_helper)) {
                    return false;
                }
            }
            reader.accept();
            return true;
        }
        if (tag == "quit") {
            depth2kin_IDL_quit_helper::s_return_helper = quit();
            yarp::os::idl::WireWriter writer(reader);
            if (!writer.isNull()) {
                if (!writer.writeListHeader(1)) {
                    return false;
                }
                if (!writer.writeBool(depth2kin_IDL_quit_helper::s_return_helper)) {
                    return false;
                }
            }
            reader.accept();
            return true;
        }
        if (tag == "help") {
            std::string functionName;
            if (!reader.readString(functionName)) {
                functionName = "--all";
            }
            auto help_strings = help(functionName);
            yarp::os::idl::WireWriter writer(reader);
            if (!writer.isNull()) {
                if (!writer.writeListHeader(2)) {
                    return false;
                }
                if (!writer.writeTag("many", 1, 0)) {
                    return false;
                }
                if (!writer.writeListBegin(BOTTLE_TAG_INT32, static_cast<uint32_t>(help_strings.size()))) {
                    return false;
                }
                for (const auto& help_string : help_strings) {
                    if (!writer.writeString(help_string)) {
                        return false;
                    }
                }
                if (!writer.writeListEnd()) {
                    return false;
                }
            }
            reader.accept();
            return true;
        }
        if (reader.noMore()) {
            reader.fail();
            return false;
        }
        std::string next_tag = reader.readTag();
        if (next_tag == "") {
            break;
        }
        tag.append("_").append(next_tag);
    }
    return false;
}
